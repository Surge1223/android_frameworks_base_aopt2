// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Format.proto

#ifndef PROTOBUF_Format_2eproto__INCLUDED
#define PROTOBUF_Format_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace aapt {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Format_2eproto();
void protobuf_AssignDesc_Format_2eproto();
void protobuf_ShutdownFile_Format_2eproto();

class ConfigDescription;
class StringPool;
class CompiledFile;
class CompiledFile_Symbol;
class ResourceTable;
class Package;
class Type;
class SymbolStatus;
class Entry;
class ConfigValue;
class Source;
class Reference;
class Id;
class String;
class RawString;
class FileReference;
class Primitive;
class Attribute;
class Attribute_Symbol;
class Style;
class Style_Entry;
class Styleable;
class Styleable_Entry;
class Array;
class Array_Entry;
class Plural;
class Plural_Entry;
class Item;
class CompoundValue;
class Value;

enum SymbolStatus_Visibility {
  SymbolStatus_Visibility_Unknown = 0,
  SymbolStatus_Visibility_Private = 1,
  SymbolStatus_Visibility_Public = 2
};
bool SymbolStatus_Visibility_IsValid(int value);
const SymbolStatus_Visibility SymbolStatus_Visibility_Visibility_MIN = SymbolStatus_Visibility_Unknown;
const SymbolStatus_Visibility SymbolStatus_Visibility_Visibility_MAX = SymbolStatus_Visibility_Public;
const int SymbolStatus_Visibility_Visibility_ARRAYSIZE = SymbolStatus_Visibility_Visibility_MAX + 1;

enum Reference_Type {
  Reference_Type_Ref = 0,
  Reference_Type_Attr = 1
};
bool Reference_Type_IsValid(int value);
const Reference_Type Reference_Type_Type_MIN = Reference_Type_Ref;
const Reference_Type Reference_Type_Type_MAX = Reference_Type_Attr;
const int Reference_Type_Type_ARRAYSIZE = Reference_Type_Type_MAX + 1;

enum Plural_Arity {
  Plural_Arity_Zero = 0,
  Plural_Arity_One = 1,
  Plural_Arity_Two = 2,
  Plural_Arity_Few = 3,
  Plural_Arity_Many = 4,
  Plural_Arity_Other = 5
};
bool Plural_Arity_IsValid(int value);
const Plural_Arity Plural_Arity_Arity_MIN = Plural_Arity_Zero;
const Plural_Arity Plural_Arity_Arity_MAX = Plural_Arity_Other;
const int Plural_Arity_Arity_ARRAYSIZE = Plural_Arity_Arity_MAX + 1;

// ===================================================================

class ConfigDescription : public ::google::protobuf::MessageLite {
 public:
  ConfigDescription();
  virtual ~ConfigDescription();

  ConfigDescription(const ConfigDescription& from);

  inline ConfigDescription& operator=(const ConfigDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConfigDescription& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigDescription* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigDescription* other);

  // implements Message ----------------------------------------------

  ConfigDescription* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigDescription& from);
  void MergeFrom(const ConfigDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string product = 2;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 2;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // @@protoc_insertion_point(class_scope:aapt.pb.ConfigDescription)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_product();
  inline void clear_has_product();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::std::string* product_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static ConfigDescription* default_instance_;
};
// -------------------------------------------------------------------

class StringPool : public ::google::protobuf::MessageLite {
 public:
  StringPool();
  virtual ~StringPool();

  StringPool(const StringPool& from);

  inline StringPool& operator=(const StringPool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StringPool& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StringPool* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StringPool* other);

  // implements Message ----------------------------------------------

  StringPool* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StringPool& from);
  void MergeFrom(const StringPool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:aapt.pb.StringPool)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static StringPool* default_instance_;
};
// -------------------------------------------------------------------

class CompiledFile_Symbol : public ::google::protobuf::MessageLite {
 public:
  CompiledFile_Symbol();
  virtual ~CompiledFile_Symbol();

  CompiledFile_Symbol(const CompiledFile_Symbol& from);

  inline CompiledFile_Symbol& operator=(const CompiledFile_Symbol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CompiledFile_Symbol& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompiledFile_Symbol* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompiledFile_Symbol* other);

  // implements Message ----------------------------------------------

  CompiledFile_Symbol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompiledFile_Symbol& from);
  void MergeFrom(const CompiledFile_Symbol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string resource_name = 1;
  inline bool has_resource_name() const;
  inline void clear_resource_name();
  static const int kResourceNameFieldNumber = 1;
  inline const ::std::string& resource_name() const;
  inline void set_resource_name(const ::std::string& value);
  inline void set_resource_name(const char* value);
  inline void set_resource_name(const char* value, size_t size);
  inline ::std::string* mutable_resource_name();
  inline ::std::string* release_resource_name();
  inline void set_allocated_resource_name(::std::string* resource_name);

  // optional uint32 line_no = 2;
  inline bool has_line_no() const;
  inline void clear_line_no();
  static const int kLineNoFieldNumber = 2;
  inline ::google::protobuf::uint32 line_no() const;
  inline void set_line_no(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.CompiledFile.Symbol)
 private:
  inline void set_has_resource_name();
  inline void clear_has_resource_name();
  inline void set_has_line_no();
  inline void clear_has_line_no();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* resource_name_;
  ::google::protobuf::uint32 line_no_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static CompiledFile_Symbol* default_instance_;
};
// -------------------------------------------------------------------

class CompiledFile : public ::google::protobuf::MessageLite {
 public:
  CompiledFile();
  virtual ~CompiledFile();

  CompiledFile(const CompiledFile& from);

  inline CompiledFile& operator=(const CompiledFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CompiledFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompiledFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompiledFile* other);

  // implements Message ----------------------------------------------

  CompiledFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompiledFile& from);
  void MergeFrom(const CompiledFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CompiledFile_Symbol Symbol;

  // accessors -------------------------------------------------------

  // optional string resource_name = 1;
  inline bool has_resource_name() const;
  inline void clear_resource_name();
  static const int kResourceNameFieldNumber = 1;
  inline const ::std::string& resource_name() const;
  inline void set_resource_name(const ::std::string& value);
  inline void set_resource_name(const char* value);
  inline void set_resource_name(const char* value, size_t size);
  inline ::std::string* mutable_resource_name();
  inline ::std::string* release_resource_name();
  inline void set_allocated_resource_name(::std::string* resource_name);

  // optional .aapt.pb.ConfigDescription config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::aapt::pb::ConfigDescription& config() const;
  inline ::aapt::pb::ConfigDescription* mutable_config();
  inline ::aapt::pb::ConfigDescription* release_config();
  inline void set_allocated_config(::aapt::pb::ConfigDescription* config);

  // optional string source_path = 3;
  inline bool has_source_path() const;
  inline void clear_source_path();
  static const int kSourcePathFieldNumber = 3;
  inline const ::std::string& source_path() const;
  inline void set_source_path(const ::std::string& value);
  inline void set_source_path(const char* value);
  inline void set_source_path(const char* value, size_t size);
  inline ::std::string* mutable_source_path();
  inline ::std::string* release_source_path();
  inline void set_allocated_source_path(::std::string* source_path);

  // repeated .aapt.pb.CompiledFile.Symbol exported_symbols = 4;
  inline int exported_symbols_size() const;
  inline void clear_exported_symbols();
  static const int kExportedSymbolsFieldNumber = 4;
  inline const ::aapt::pb::CompiledFile_Symbol& exported_symbols(int index) const;
  inline ::aapt::pb::CompiledFile_Symbol* mutable_exported_symbols(int index);
  inline ::aapt::pb::CompiledFile_Symbol* add_exported_symbols();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::CompiledFile_Symbol >&
      exported_symbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::CompiledFile_Symbol >*
      mutable_exported_symbols();

  // @@protoc_insertion_point(class_scope:aapt.pb.CompiledFile)
 private:
  inline void set_has_resource_name();
  inline void clear_has_resource_name();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_source_path();
  inline void clear_has_source_path();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* resource_name_;
  ::aapt::pb::ConfigDescription* config_;
  ::std::string* source_path_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::CompiledFile_Symbol > exported_symbols_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static CompiledFile* default_instance_;
};
// -------------------------------------------------------------------

class ResourceTable : public ::google::protobuf::MessageLite {
 public:
  ResourceTable();
  virtual ~ResourceTable();

  ResourceTable(const ResourceTable& from);

  inline ResourceTable& operator=(const ResourceTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ResourceTable& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResourceTable* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResourceTable* other);

  // implements Message ----------------------------------------------

  ResourceTable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResourceTable& from);
  void MergeFrom(const ResourceTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.StringPool string_pool = 1;
  inline bool has_string_pool() const;
  inline void clear_string_pool();
  static const int kStringPoolFieldNumber = 1;
  inline const ::aapt::pb::StringPool& string_pool() const;
  inline ::aapt::pb::StringPool* mutable_string_pool();
  inline ::aapt::pb::StringPool* release_string_pool();
  inline void set_allocated_string_pool(::aapt::pb::StringPool* string_pool);

  // optional .aapt.pb.StringPool source_pool = 2;
  inline bool has_source_pool() const;
  inline void clear_source_pool();
  static const int kSourcePoolFieldNumber = 2;
  inline const ::aapt::pb::StringPool& source_pool() const;
  inline ::aapt::pb::StringPool* mutable_source_pool();
  inline ::aapt::pb::StringPool* release_source_pool();
  inline void set_allocated_source_pool(::aapt::pb::StringPool* source_pool);

  // optional .aapt.pb.StringPool symbol_pool = 3;
  inline bool has_symbol_pool() const;
  inline void clear_symbol_pool();
  static const int kSymbolPoolFieldNumber = 3;
  inline const ::aapt::pb::StringPool& symbol_pool() const;
  inline ::aapt::pb::StringPool* mutable_symbol_pool();
  inline ::aapt::pb::StringPool* release_symbol_pool();
  inline void set_allocated_symbol_pool(::aapt::pb::StringPool* symbol_pool);

  // repeated .aapt.pb.Package packages = 4;
  inline int packages_size() const;
  inline void clear_packages();
  static const int kPackagesFieldNumber = 4;
  inline const ::aapt::pb::Package& packages(int index) const;
  inline ::aapt::pb::Package* mutable_packages(int index);
  inline ::aapt::pb::Package* add_packages();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >&
      packages() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >*
      mutable_packages();

  // @@protoc_insertion_point(class_scope:aapt.pb.ResourceTable)
 private:
  inline void set_has_string_pool();
  inline void clear_has_string_pool();
  inline void set_has_source_pool();
  inline void clear_has_source_pool();
  inline void set_has_symbol_pool();
  inline void clear_has_symbol_pool();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::StringPool* string_pool_;
  ::aapt::pb::StringPool* source_pool_;
  ::aapt::pb::StringPool* symbol_pool_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package > packages_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static ResourceTable* default_instance_;
};
// -------------------------------------------------------------------

class Package : public ::google::protobuf::MessageLite {
 public:
  Package();
  virtual ~Package();

  Package(const Package& from);

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Package& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Package* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Package* other);

  // implements Message ----------------------------------------------

  Package* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Package& from);
  void MergeFrom(const Package& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 package_id = 1;
  inline bool has_package_id() const;
  inline void clear_package_id();
  static const int kPackageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 package_id() const;
  inline void set_package_id(::google::protobuf::uint32 value);

  // optional string package_name = 2;
  inline bool has_package_name() const;
  inline void clear_package_name();
  static const int kPackageNameFieldNumber = 2;
  inline const ::std::string& package_name() const;
  inline void set_package_name(const ::std::string& value);
  inline void set_package_name(const char* value);
  inline void set_package_name(const char* value, size_t size);
  inline ::std::string* mutable_package_name();
  inline ::std::string* release_package_name();
  inline void set_allocated_package_name(::std::string* package_name);

  // repeated .aapt.pb.Type types = 3;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 3;
  inline const ::aapt::pb::Type& types(int index) const;
  inline ::aapt::pb::Type* mutable_types(int index);
  inline ::aapt::pb::Type* add_types();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >&
      types() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:aapt.pb.Package)
 private:
  inline void set_has_package_id();
  inline void clear_has_package_id();
  inline void set_has_package_name();
  inline void clear_has_package_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* package_name_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type > types_;
  ::google::protobuf::uint32 package_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Package* default_instance_;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::MessageLite {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Type& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Type* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Type* other);

  // implements Message ----------------------------------------------

  Type* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .aapt.pb.Entry entries = 3;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 3;
  inline const ::aapt::pb::Entry& entries(int index) const;
  inline ::aapt::pb::Entry* mutable_entries(int index);
  inline ::aapt::pb::Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:aapt.pb.Type)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry > entries_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Type* default_instance_;
};
// -------------------------------------------------------------------

class SymbolStatus : public ::google::protobuf::MessageLite {
 public:
  SymbolStatus();
  virtual ~SymbolStatus();

  SymbolStatus(const SymbolStatus& from);

  inline SymbolStatus& operator=(const SymbolStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SymbolStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SymbolStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SymbolStatus* other);

  // implements Message ----------------------------------------------

  SymbolStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SymbolStatus& from);
  void MergeFrom(const SymbolStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SymbolStatus_Visibility Visibility;
  static const Visibility Unknown = SymbolStatus_Visibility_Unknown;
  static const Visibility Private = SymbolStatus_Visibility_Private;
  static const Visibility Public = SymbolStatus_Visibility_Public;
  static inline bool Visibility_IsValid(int value) {
    return SymbolStatus_Visibility_IsValid(value);
  }
  static const Visibility Visibility_MIN =
    SymbolStatus_Visibility_Visibility_MIN;
  static const Visibility Visibility_MAX =
    SymbolStatus_Visibility_Visibility_MAX;
  static const int Visibility_ARRAYSIZE =
    SymbolStatus_Visibility_Visibility_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  inline ::aapt::pb::SymbolStatus_Visibility visibility() const;
  inline void set_visibility(::aapt::pb::SymbolStatus_Visibility value);

  // optional .aapt.pb.Source source = 2;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 2;
  inline const ::aapt::pb::Source& source() const;
  inline ::aapt::pb::Source* mutable_source();
  inline ::aapt::pb::Source* release_source();
  inline void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:aapt.pb.SymbolStatus)
 private:
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::std::string* comment_;
  int visibility_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static SymbolStatus* default_instance_;
};
// -------------------------------------------------------------------

class Entry : public ::google::protobuf::MessageLite {
 public:
  Entry();
  virtual ~Entry();

  Entry(const Entry& from);

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Entry* other);

  // implements Message ----------------------------------------------

  Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .aapt.pb.SymbolStatus symbol_status = 3;
  inline bool has_symbol_status() const;
  inline void clear_symbol_status();
  static const int kSymbolStatusFieldNumber = 3;
  inline const ::aapt::pb::SymbolStatus& symbol_status() const;
  inline ::aapt::pb::SymbolStatus* mutable_symbol_status();
  inline ::aapt::pb::SymbolStatus* release_symbol_status();
  inline void set_allocated_symbol_status(::aapt::pb::SymbolStatus* symbol_status);

  // repeated .aapt.pb.ConfigValue config_values = 4;
  inline int config_values_size() const;
  inline void clear_config_values();
  static const int kConfigValuesFieldNumber = 4;
  inline const ::aapt::pb::ConfigValue& config_values(int index) const;
  inline ::aapt::pb::ConfigValue* mutable_config_values(int index);
  inline ::aapt::pb::ConfigValue* add_config_values();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >&
      config_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >*
      mutable_config_values();

  // @@protoc_insertion_point(class_scope:aapt.pb.Entry)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_symbol_status();
  inline void clear_has_symbol_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::aapt::pb::SymbolStatus* symbol_status_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue > config_values_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Entry* default_instance_;
};
// -------------------------------------------------------------------

class ConfigValue : public ::google::protobuf::MessageLite {
 public:
  ConfigValue();
  virtual ~ConfigValue();

  ConfigValue(const ConfigValue& from);

  inline ConfigValue& operator=(const ConfigValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConfigValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigValue* other);

  // implements Message ----------------------------------------------

  ConfigValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigValue& from);
  void MergeFrom(const ConfigValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.ConfigDescription config = 1;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 1;
  inline const ::aapt::pb::ConfigDescription& config() const;
  inline ::aapt::pb::ConfigDescription* mutable_config();
  inline ::aapt::pb::ConfigDescription* release_config();
  inline void set_allocated_config(::aapt::pb::ConfigDescription* config);

  // optional .aapt.pb.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::aapt::pb::Value& value() const;
  inline ::aapt::pb::Value* mutable_value();
  inline ::aapt::pb::Value* release_value();
  inline void set_allocated_value(::aapt::pb::Value* value);

  // @@protoc_insertion_point(class_scope:aapt.pb.ConfigValue)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::ConfigDescription* config_;
  ::aapt::pb::Value* value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static ConfigValue* default_instance_;
};
// -------------------------------------------------------------------

class Source : public ::google::protobuf::MessageLite {
 public:
  Source();
  virtual ~Source();

  Source(const Source& from);

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Source& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Source* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Source* other);

  // implements Message ----------------------------------------------

  Source* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Source& from);
  void MergeFrom(const Source& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 path_idx = 1;
  inline bool has_path_idx() const;
  inline void clear_path_idx();
  static const int kPathIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 path_idx() const;
  inline void set_path_idx(::google::protobuf::uint32 value);

  // optional uint32 line_no = 2;
  inline bool has_line_no() const;
  inline void clear_line_no();
  static const int kLineNoFieldNumber = 2;
  inline ::google::protobuf::uint32 line_no() const;
  inline void set_line_no(::google::protobuf::uint32 value);

  // optional uint32 col_no = 3;
  inline bool has_col_no() const;
  inline void clear_col_no();
  static const int kColNoFieldNumber = 3;
  inline ::google::protobuf::uint32 col_no() const;
  inline void set_col_no(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Source)
 private:
  inline void set_has_path_idx();
  inline void clear_has_path_idx();
  inline void set_has_line_no();
  inline void clear_has_line_no();
  inline void set_has_col_no();
  inline void clear_has_col_no();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 path_idx_;
  ::google::protobuf::uint32 line_no_;
  ::google::protobuf::uint32 col_no_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Source* default_instance_;
};
// -------------------------------------------------------------------

class Reference : public ::google::protobuf::MessageLite {
 public:
  Reference();
  virtual ~Reference();

  Reference(const Reference& from);

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Reference& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Reference* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Reference* other);

  // implements Message ----------------------------------------------

  Reference* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Reference& from);
  void MergeFrom(const Reference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Reference_Type Type;
  static const Type Ref = Reference_Type_Ref;
  static const Type Attr = Reference_Type_Attr;
  static inline bool Type_IsValid(int value) {
    return Reference_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Reference_Type_Type_MIN;
  static const Type Type_MAX =
    Reference_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Reference_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Reference.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::aapt::pb::Reference_Type type() const;
  inline void set_type(::aapt::pb::Reference_Type value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 symbol_idx = 3;
  inline bool has_symbol_idx() const;
  inline void clear_symbol_idx();
  static const int kSymbolIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 symbol_idx() const;
  inline void set_symbol_idx(::google::protobuf::uint32 value);

  // optional bool private = 4;
  inline bool has_private_() const;
  inline void clear_private_();
  static const int kPrivateFieldNumber = 4;
  inline bool private_() const;
  inline void set_private_(bool value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Reference)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_symbol_idx();
  inline void clear_has_symbol_idx();
  inline void set_has_private_();
  inline void clear_has_private_();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 symbol_idx_;
  bool private__;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Reference* default_instance_;
};
// -------------------------------------------------------------------

class Id : public ::google::protobuf::MessageLite {
 public:
  Id();
  virtual ~Id();

  Id(const Id& from);

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Id& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Id* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Id* other);

  // implements Message ----------------------------------------------

  Id* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Id& from);
  void MergeFrom(const Id& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aapt.pb.Id)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Id* default_instance_;
};
// -------------------------------------------------------------------

class String : public ::google::protobuf::MessageLite {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const String& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const String* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(String* other);

  // implements Message ----------------------------------------------

  String* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 idx() const;
  inline void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.String)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 idx_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static String* default_instance_;
};
// -------------------------------------------------------------------

class RawString : public ::google::protobuf::MessageLite {
 public:
  RawString();
  virtual ~RawString();

  RawString(const RawString& from);

  inline RawString& operator=(const RawString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RawString& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RawString* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RawString* other);

  // implements Message ----------------------------------------------

  RawString* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RawString& from);
  void MergeFrom(const RawString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 idx() const;
  inline void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.RawString)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 idx_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static RawString* default_instance_;
};
// -------------------------------------------------------------------

class FileReference : public ::google::protobuf::MessageLite {
 public:
  FileReference();
  virtual ~FileReference();

  FileReference(const FileReference& from);

  inline FileReference& operator=(const FileReference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FileReference& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileReference* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileReference* other);

  // implements Message ----------------------------------------------

  FileReference* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileReference& from);
  void MergeFrom(const FileReference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 path_idx = 1;
  inline bool has_path_idx() const;
  inline void clear_path_idx();
  static const int kPathIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 path_idx() const;
  inline void set_path_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.FileReference)
 private:
  inline void set_has_path_idx();
  inline void clear_has_path_idx();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 path_idx_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static FileReference* default_instance_;
};
// -------------------------------------------------------------------

class Primitive : public ::google::protobuf::MessageLite {
 public:
  Primitive();
  virtual ~Primitive();

  Primitive(const Primitive& from);

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Primitive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Primitive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Primitive* other);

  // implements Message ----------------------------------------------

  Primitive* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Primitive& from);
  void MergeFrom(const Primitive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::uint32 data() const;
  inline void set_data(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Primitive* default_instance_;
};
// -------------------------------------------------------------------

class Attribute_Symbol : public ::google::protobuf::MessageLite {
 public:
  Attribute_Symbol();
  virtual ~Attribute_Symbol();

  Attribute_Symbol(const Attribute_Symbol& from);

  inline Attribute_Symbol& operator=(const Attribute_Symbol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Attribute_Symbol& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Attribute_Symbol* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Attribute_Symbol* other);

  // implements Message ----------------------------------------------

  Attribute_Symbol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Attribute_Symbol& from);
  void MergeFrom(const Attribute_Symbol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::aapt::pb::Source& source() const;
  inline ::aapt::pb::Source* mutable_source();
  inline ::aapt::pb::Source* release_source();
  inline void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Reference name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::aapt::pb::Reference& name() const;
  inline ::aapt::pb::Reference* mutable_name();
  inline ::aapt::pb::Reference* release_name();
  inline void set_allocated_name(::aapt::pb::Reference* name);

  // optional uint32 value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute.Symbol)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::std::string* comment_;
  ::aapt::pb::Reference* name_;
  ::google::protobuf::uint32 value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Attribute_Symbol* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::MessageLite {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Attribute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Attribute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Attribute* other);

  // implements Message ----------------------------------------------

  Attribute* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Attribute_Symbol Symbol;

  // accessors -------------------------------------------------------

  // optional uint32 format_flags = 1;
  inline bool has_format_flags() const;
  inline void clear_format_flags();
  static const int kFormatFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 format_flags() const;
  inline void set_format_flags(::google::protobuf::uint32 value);

  // optional int32 min_int = 2;
  inline bool has_min_int() const;
  inline void clear_min_int();
  static const int kMinIntFieldNumber = 2;
  inline ::google::protobuf::int32 min_int() const;
  inline void set_min_int(::google::protobuf::int32 value);

  // optional int32 max_int = 3;
  inline bool has_max_int() const;
  inline void clear_max_int();
  static const int kMaxIntFieldNumber = 3;
  inline ::google::protobuf::int32 max_int() const;
  inline void set_max_int(::google::protobuf::int32 value);

  // repeated .aapt.pb.Attribute.Symbol symbols = 4;
  inline int symbols_size() const;
  inline void clear_symbols();
  static const int kSymbolsFieldNumber = 4;
  inline const ::aapt::pb::Attribute_Symbol& symbols(int index) const;
  inline ::aapt::pb::Attribute_Symbol* mutable_symbols(int index);
  inline ::aapt::pb::Attribute_Symbol* add_symbols();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
      symbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
      mutable_symbols();

  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute)
 private:
  inline void set_has_format_flags();
  inline void clear_has_format_flags();
  inline void set_has_min_int();
  inline void clear_has_min_int();
  inline void set_has_max_int();
  inline void clear_has_max_int();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 format_flags_;
  ::google::protobuf::int32 min_int_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol > symbols_;
  ::google::protobuf::int32 max_int_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// -------------------------------------------------------------------

class Style_Entry : public ::google::protobuf::MessageLite {
 public:
  Style_Entry();
  virtual ~Style_Entry();

  Style_Entry(const Style_Entry& from);

  inline Style_Entry& operator=(const Style_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Style_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Style_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Style_Entry* other);

  // implements Message ----------------------------------------------

  Style_Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Style_Entry& from);
  void MergeFrom(const Style_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::aapt::pb::Source& source() const;
  inline ::aapt::pb::Source* mutable_source();
  inline ::aapt::pb::Source* release_source();
  inline void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Reference key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::aapt::pb::Reference& key() const;
  inline ::aapt::pb::Reference* mutable_key();
  inline ::aapt::pb::Reference* release_key();
  inline void set_allocated_key(::aapt::pb::Reference* key);

  // optional .aapt.pb.Item item = 4;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 4;
  inline const ::aapt::pb::Item& item() const;
  inline ::aapt::pb::Item* mutable_item();
  inline ::aapt::pb::Item* release_item();
  inline void set_allocated_item(::aapt::pb::Item* item);

  // @@protoc_insertion_point(class_scope:aapt.pb.Style.Entry)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_item();
  inline void clear_has_item();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::std::string* comment_;
  ::aapt::pb::Reference* key_;
  ::aapt::pb::Item* item_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Style_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Style : public ::google::protobuf::MessageLite {
 public:
  Style();
  virtual ~Style();

  Style(const Style& from);

  inline Style& operator=(const Style& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Style& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Style* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Style* other);

  // implements Message ----------------------------------------------

  Style* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Style& from);
  void MergeFrom(const Style& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Style_Entry Entry;

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Reference parent = 1;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 1;
  inline const ::aapt::pb::Reference& parent() const;
  inline ::aapt::pb::Reference* mutable_parent();
  inline ::aapt::pb::Reference* release_parent();
  inline void set_allocated_parent(::aapt::pb::Reference* parent);

  // optional .aapt.pb.Source parent_source = 2;
  inline bool has_parent_source() const;
  inline void clear_parent_source();
  static const int kParentSourceFieldNumber = 2;
  inline const ::aapt::pb::Source& parent_source() const;
  inline ::aapt::pb::Source* mutable_parent_source();
  inline ::aapt::pb::Source* release_parent_source();
  inline void set_allocated_parent_source(::aapt::pb::Source* parent_source);

  // repeated .aapt.pb.Style.Entry entries = 3;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 3;
  inline const ::aapt::pb::Style_Entry& entries(int index) const;
  inline ::aapt::pb::Style_Entry* mutable_entries(int index);
  inline ::aapt::pb::Style_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:aapt.pb.Style)
 private:
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_parent_source();
  inline void clear_has_parent_source();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Reference* parent_;
  ::aapt::pb::Source* parent_source_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry > entries_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Style* default_instance_;
};
// -------------------------------------------------------------------

class Styleable_Entry : public ::google::protobuf::MessageLite {
 public:
  Styleable_Entry();
  virtual ~Styleable_Entry();

  Styleable_Entry(const Styleable_Entry& from);

  inline Styleable_Entry& operator=(const Styleable_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Styleable_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Styleable_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Styleable_Entry* other);

  // implements Message ----------------------------------------------

  Styleable_Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Styleable_Entry& from);
  void MergeFrom(const Styleable_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::aapt::pb::Source& source() const;
  inline ::aapt::pb::Source* mutable_source();
  inline ::aapt::pb::Source* release_source();
  inline void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Reference attr = 3;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 3;
  inline const ::aapt::pb::Reference& attr() const;
  inline ::aapt::pb::Reference* mutable_attr();
  inline ::aapt::pb::Reference* release_attr();
  inline void set_allocated_attr(::aapt::pb::Reference* attr);

  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable.Entry)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_attr();
  inline void clear_has_attr();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::std::string* comment_;
  ::aapt::pb::Reference* attr_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Styleable_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Styleable : public ::google::protobuf::MessageLite {
 public:
  Styleable();
  virtual ~Styleable();

  Styleable(const Styleable& from);

  inline Styleable& operator=(const Styleable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Styleable& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Styleable* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Styleable* other);

  // implements Message ----------------------------------------------

  Styleable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Styleable& from);
  void MergeFrom(const Styleable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Styleable_Entry Entry;

  // accessors -------------------------------------------------------

  // repeated .aapt.pb.Styleable.Entry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::aapt::pb::Styleable_Entry& entries(int index) const;
  inline ::aapt::pb::Styleable_Entry* mutable_entries(int index);
  inline ::aapt::pb::Styleable_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry > entries_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Styleable* default_instance_;
};
// -------------------------------------------------------------------

class Array_Entry : public ::google::protobuf::MessageLite {
 public:
  Array_Entry();
  virtual ~Array_Entry();

  Array_Entry(const Array_Entry& from);

  inline Array_Entry& operator=(const Array_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Array_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Array_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Array_Entry* other);

  // implements Message ----------------------------------------------

  Array_Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Array_Entry& from);
  void MergeFrom(const Array_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::aapt::pb::Source& source() const;
  inline ::aapt::pb::Source* mutable_source();
  inline ::aapt::pb::Source* release_source();
  inline void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Item item = 3;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::aapt::pb::Item& item() const;
  inline ::aapt::pb::Item* mutable_item();
  inline ::aapt::pb::Item* release_item();
  inline void set_allocated_item(::aapt::pb::Item* item);

  // @@protoc_insertion_point(class_scope:aapt.pb.Array.Entry)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_item();
  inline void clear_has_item();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::std::string* comment_;
  ::aapt::pb::Item* item_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Array_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Array : public ::google::protobuf::MessageLite {
 public:
  Array();
  virtual ~Array();

  Array(const Array& from);

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Array& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Array* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Array* other);

  // implements Message ----------------------------------------------

  Array* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Array& from);
  void MergeFrom(const Array& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Array_Entry Entry;

  // accessors -------------------------------------------------------

  // repeated .aapt.pb.Array.Entry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::aapt::pb::Array_Entry& entries(int index) const;
  inline ::aapt::pb::Array_Entry* mutable_entries(int index);
  inline ::aapt::pb::Array_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:aapt.pb.Array)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Entry > entries_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Array* default_instance_;
};
// -------------------------------------------------------------------

class Plural_Entry : public ::google::protobuf::MessageLite {
 public:
  Plural_Entry();
  virtual ~Plural_Entry();

  Plural_Entry(const Plural_Entry& from);

  inline Plural_Entry& operator=(const Plural_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Plural_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Plural_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Plural_Entry* other);

  // implements Message ----------------------------------------------

  Plural_Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Plural_Entry& from);
  void MergeFrom(const Plural_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::aapt::pb::Source& source() const;
  inline ::aapt::pb::Source* mutable_source();
  inline ::aapt::pb::Source* release_source();
  inline void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Plural.Arity arity = 3;
  inline bool has_arity() const;
  inline void clear_arity();
  static const int kArityFieldNumber = 3;
  inline ::aapt::pb::Plural_Arity arity() const;
  inline void set_arity(::aapt::pb::Plural_Arity value);

  // optional .aapt.pb.Item item = 4;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 4;
  inline const ::aapt::pb::Item& item() const;
  inline ::aapt::pb::Item* mutable_item();
  inline ::aapt::pb::Item* release_item();
  inline void set_allocated_item(::aapt::pb::Item* item);

  // @@protoc_insertion_point(class_scope:aapt.pb.Plural.Entry)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_arity();
  inline void clear_has_arity();
  inline void set_has_item();
  inline void clear_has_item();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::std::string* comment_;
  ::aapt::pb::Item* item_;
  int arity_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Plural_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Plural : public ::google::protobuf::MessageLite {
 public:
  Plural();
  virtual ~Plural();

  Plural(const Plural& from);

  inline Plural& operator=(const Plural& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Plural& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Plural* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Plural* other);

  // implements Message ----------------------------------------------

  Plural* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Plural& from);
  void MergeFrom(const Plural& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Plural_Entry Entry;

  typedef Plural_Arity Arity;
  static const Arity Zero = Plural_Arity_Zero;
  static const Arity One = Plural_Arity_One;
  static const Arity Two = Plural_Arity_Two;
  static const Arity Few = Plural_Arity_Few;
  static const Arity Many = Plural_Arity_Many;
  static const Arity Other = Plural_Arity_Other;
  static inline bool Arity_IsValid(int value) {
    return Plural_Arity_IsValid(value);
  }
  static const Arity Arity_MIN =
    Plural_Arity_Arity_MIN;
  static const Arity Arity_MAX =
    Plural_Arity_Arity_MAX;
  static const int Arity_ARRAYSIZE =
    Plural_Arity_Arity_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aapt.pb.Plural.Entry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::aapt::pb::Plural_Entry& entries(int index) const;
  inline ::aapt::pb::Plural_Entry* mutable_entries(int index);
  inline ::aapt::pb::Plural_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:aapt.pb.Plural)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry > entries_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Plural* default_instance_;
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::MessageLite {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Item& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Item* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Reference ref = 1;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 1;
  inline const ::aapt::pb::Reference& ref() const;
  inline ::aapt::pb::Reference* mutable_ref();
  inline ::aapt::pb::Reference* release_ref();
  inline void set_allocated_ref(::aapt::pb::Reference* ref);

  // optional .aapt.pb.String str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::aapt::pb::String& str() const;
  inline ::aapt::pb::String* mutable_str();
  inline ::aapt::pb::String* release_str();
  inline void set_allocated_str(::aapt::pb::String* str);

  // optional .aapt.pb.RawString raw_str = 3;
  inline bool has_raw_str() const;
  inline void clear_raw_str();
  static const int kRawStrFieldNumber = 3;
  inline const ::aapt::pb::RawString& raw_str() const;
  inline ::aapt::pb::RawString* mutable_raw_str();
  inline ::aapt::pb::RawString* release_raw_str();
  inline void set_allocated_raw_str(::aapt::pb::RawString* raw_str);

  // optional .aapt.pb.FileReference file = 4;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 4;
  inline const ::aapt::pb::FileReference& file() const;
  inline ::aapt::pb::FileReference* mutable_file();
  inline ::aapt::pb::FileReference* release_file();
  inline void set_allocated_file(::aapt::pb::FileReference* file);

  // optional .aapt.pb.Id id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline const ::aapt::pb::Id& id() const;
  inline ::aapt::pb::Id* mutable_id();
  inline ::aapt::pb::Id* release_id();
  inline void set_allocated_id(::aapt::pb::Id* id);

  // optional .aapt.pb.Primitive prim = 6;
  inline bool has_prim() const;
  inline void clear_prim();
  static const int kPrimFieldNumber = 6;
  inline const ::aapt::pb::Primitive& prim() const;
  inline ::aapt::pb::Primitive* mutable_prim();
  inline ::aapt::pb::Primitive* release_prim();
  inline void set_allocated_prim(::aapt::pb::Primitive* prim);

  // @@protoc_insertion_point(class_scope:aapt.pb.Item)
 private:
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_raw_str();
  inline void clear_has_raw_str();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_prim();
  inline void clear_has_prim();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Reference* ref_;
  ::aapt::pb::String* str_;
  ::aapt::pb::RawString* raw_str_;
  ::aapt::pb::FileReference* file_;
  ::aapt::pb::Id* id_;
  ::aapt::pb::Primitive* prim_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class CompoundValue : public ::google::protobuf::MessageLite {
 public:
  CompoundValue();
  virtual ~CompoundValue();

  CompoundValue(const CompoundValue& from);

  inline CompoundValue& operator=(const CompoundValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CompoundValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompoundValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompoundValue* other);

  // implements Message ----------------------------------------------

  CompoundValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompoundValue& from);
  void MergeFrom(const CompoundValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Attribute attr = 1;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 1;
  inline const ::aapt::pb::Attribute& attr() const;
  inline ::aapt::pb::Attribute* mutable_attr();
  inline ::aapt::pb::Attribute* release_attr();
  inline void set_allocated_attr(::aapt::pb::Attribute* attr);

  // optional .aapt.pb.Style style = 2;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 2;
  inline const ::aapt::pb::Style& style() const;
  inline ::aapt::pb::Style* mutable_style();
  inline ::aapt::pb::Style* release_style();
  inline void set_allocated_style(::aapt::pb::Style* style);

  // optional .aapt.pb.Styleable styleable = 3;
  inline bool has_styleable() const;
  inline void clear_styleable();
  static const int kStyleableFieldNumber = 3;
  inline const ::aapt::pb::Styleable& styleable() const;
  inline ::aapt::pb::Styleable* mutable_styleable();
  inline ::aapt::pb::Styleable* release_styleable();
  inline void set_allocated_styleable(::aapt::pb::Styleable* styleable);

  // optional .aapt.pb.Array array = 4;
  inline bool has_array() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 4;
  inline const ::aapt::pb::Array& array() const;
  inline ::aapt::pb::Array* mutable_array();
  inline ::aapt::pb::Array* release_array();
  inline void set_allocated_array(::aapt::pb::Array* array);

  // optional .aapt.pb.Plural plural = 5;
  inline bool has_plural() const;
  inline void clear_plural();
  static const int kPluralFieldNumber = 5;
  inline const ::aapt::pb::Plural& plural() const;
  inline ::aapt::pb::Plural* mutable_plural();
  inline ::aapt::pb::Plural* release_plural();
  inline void set_allocated_plural(::aapt::pb::Plural* plural);

  // @@protoc_insertion_point(class_scope:aapt.pb.CompoundValue)
 private:
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_styleable();
  inline void clear_has_styleable();
  inline void set_has_array();
  inline void clear_has_array();
  inline void set_has_plural();
  inline void clear_has_plural();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Attribute* attr_;
  ::aapt::pb::Style* style_;
  ::aapt::pb::Styleable* styleable_;
  ::aapt::pb::Array* array_;
  ::aapt::pb::Plural* plural_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static CompoundValue* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::MessageLite {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Value& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Value* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  Value* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::aapt::pb::Source& source() const;
  inline ::aapt::pb::Source* mutable_source();
  inline ::aapt::pb::Source* release_source();
  inline void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional bool weak = 3;
  inline bool has_weak() const;
  inline void clear_weak();
  static const int kWeakFieldNumber = 3;
  inline bool weak() const;
  inline void set_weak(bool value);

  // optional .aapt.pb.Item item = 4;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 4;
  inline const ::aapt::pb::Item& item() const;
  inline ::aapt::pb::Item* mutable_item();
  inline ::aapt::pb::Item* release_item();
  inline void set_allocated_item(::aapt::pb::Item* item);

  // optional .aapt.pb.CompoundValue compound_value = 5;
  inline bool has_compound_value() const;
  inline void clear_compound_value();
  static const int kCompoundValueFieldNumber = 5;
  inline const ::aapt::pb::CompoundValue& compound_value() const;
  inline ::aapt::pb::CompoundValue* mutable_compound_value();
  inline ::aapt::pb::CompoundValue* release_compound_value();
  inline void set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Value)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_weak();
  inline void clear_has_weak();
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_compound_value();
  inline void clear_has_compound_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::std::string* comment_;
  ::aapt::pb::Item* item_;
  ::aapt::pb::CompoundValue* compound_value_;
  bool weak_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Format_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Format_2eproto();
  #endif
  friend void protobuf_AssignDesc_Format_2eproto();
  friend void protobuf_ShutdownFile_Format_2eproto();

  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// ===================================================================


// ===================================================================

// ConfigDescription

// optional bytes data = 1;
inline bool ConfigDescription::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigDescription::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigDescription::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigDescription::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ConfigDescription::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigDescription.data)
  return *data_;
}
inline void ConfigDescription::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.ConfigDescription.data)
}
inline void ConfigDescription::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.ConfigDescription.data)
}
inline void ConfigDescription::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.ConfigDescription.data)
}
inline ::std::string* ConfigDescription::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigDescription.data)
  return data_;
}
inline ::std::string* ConfigDescription::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConfigDescription::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigDescription.data)
}

// optional string product = 2;
inline bool ConfigDescription::has_product() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigDescription::set_has_product() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigDescription::clear_has_product() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigDescription::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& ConfigDescription::product() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigDescription.product)
  return *product_;
}
inline void ConfigDescription::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.ConfigDescription.product)
}
inline void ConfigDescription::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.ConfigDescription.product)
}
inline void ConfigDescription::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.ConfigDescription.product)
}
inline ::std::string* ConfigDescription::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigDescription.product)
  return product_;
}
inline ::std::string* ConfigDescription::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConfigDescription::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigDescription.product)
}

// -------------------------------------------------------------------

// StringPool

// optional bytes data = 1;
inline bool StringPool::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringPool::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringPool::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringPool::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& StringPool::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StringPool.data)
  return *data_;
}
inline void StringPool::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.StringPool.data)
}
inline void StringPool::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.StringPool.data)
}
inline void StringPool::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.StringPool.data)
}
inline ::std::string* StringPool::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.StringPool.data)
  return data_;
}
inline ::std::string* StringPool::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StringPool::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StringPool.data)
}

// -------------------------------------------------------------------

// CompiledFile_Symbol

// optional string resource_name = 1;
inline bool CompiledFile_Symbol::has_resource_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompiledFile_Symbol::set_has_resource_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompiledFile_Symbol::clear_has_resource_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompiledFile_Symbol::clear_resource_name() {
  if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_->clear();
  }
  clear_has_resource_name();
}
inline const ::std::string& CompiledFile_Symbol::resource_name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompiledFile.Symbol.resource_name)
  return *resource_name_;
}
inline void CompiledFile_Symbol::set_resource_name(const ::std::string& value) {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  resource_name_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.CompiledFile.Symbol.resource_name)
}
inline void CompiledFile_Symbol::set_resource_name(const char* value) {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  resource_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.CompiledFile.Symbol.resource_name)
}
inline void CompiledFile_Symbol::set_resource_name(const char* value, size_t size) {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  resource_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.CompiledFile.Symbol.resource_name)
}
inline ::std::string* CompiledFile_Symbol::mutable_resource_name() {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompiledFile.Symbol.resource_name)
  return resource_name_;
}
inline ::std::string* CompiledFile_Symbol::release_resource_name() {
  clear_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resource_name_;
    resource_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CompiledFile_Symbol::set_allocated_resource_name(::std::string* resource_name) {
  if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resource_name_;
  }
  if (resource_name) {
    set_has_resource_name();
    resource_name_ = resource_name;
  } else {
    clear_has_resource_name();
    resource_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompiledFile.Symbol.resource_name)
}

// optional uint32 line_no = 2;
inline bool CompiledFile_Symbol::has_line_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompiledFile_Symbol::set_has_line_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompiledFile_Symbol::clear_has_line_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompiledFile_Symbol::clear_line_no() {
  line_no_ = 0u;
  clear_has_line_no();
}
inline ::google::protobuf::uint32 CompiledFile_Symbol::line_no() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompiledFile.Symbol.line_no)
  return line_no_;
}
inline void CompiledFile_Symbol::set_line_no(::google::protobuf::uint32 value) {
  set_has_line_no();
  line_no_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.CompiledFile.Symbol.line_no)
}

// -------------------------------------------------------------------

// CompiledFile

// optional string resource_name = 1;
inline bool CompiledFile::has_resource_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompiledFile::set_has_resource_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompiledFile::clear_has_resource_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompiledFile::clear_resource_name() {
  if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_->clear();
  }
  clear_has_resource_name();
}
inline const ::std::string& CompiledFile::resource_name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompiledFile.resource_name)
  return *resource_name_;
}
inline void CompiledFile::set_resource_name(const ::std::string& value) {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  resource_name_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.CompiledFile.resource_name)
}
inline void CompiledFile::set_resource_name(const char* value) {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  resource_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.CompiledFile.resource_name)
}
inline void CompiledFile::set_resource_name(const char* value, size_t size) {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  resource_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.CompiledFile.resource_name)
}
inline ::std::string* CompiledFile::mutable_resource_name() {
  set_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompiledFile.resource_name)
  return resource_name_;
}
inline ::std::string* CompiledFile::release_resource_name() {
  clear_has_resource_name();
  if (resource_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resource_name_;
    resource_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CompiledFile::set_allocated_resource_name(::std::string* resource_name) {
  if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resource_name_;
  }
  if (resource_name) {
    set_has_resource_name();
    resource_name_ = resource_name;
  } else {
    clear_has_resource_name();
    resource_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompiledFile.resource_name)
}

// optional .aapt.pb.ConfigDescription config = 2;
inline bool CompiledFile::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompiledFile::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompiledFile::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompiledFile::clear_config() {
  if (config_ != NULL) config_->::aapt::pb::ConfigDescription::Clear();
  clear_has_config();
}
inline const ::aapt::pb::ConfigDescription& CompiledFile::config() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompiledFile.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::aapt::pb::ConfigDescription* CompiledFile::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::aapt::pb::ConfigDescription;
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompiledFile.config)
  return config_;
}
inline ::aapt::pb::ConfigDescription* CompiledFile::release_config() {
  clear_has_config();
  ::aapt::pb::ConfigDescription* temp = config_;
  config_ = NULL;
  return temp;
}
inline void CompiledFile::set_allocated_config(::aapt::pb::ConfigDescription* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompiledFile.config)
}

// optional string source_path = 3;
inline bool CompiledFile::has_source_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompiledFile::set_has_source_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompiledFile::clear_has_source_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompiledFile::clear_source_path() {
  if (source_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_path_->clear();
  }
  clear_has_source_path();
}
inline const ::std::string& CompiledFile::source_path() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompiledFile.source_path)
  return *source_path_;
}
inline void CompiledFile::set_source_path(const ::std::string& value) {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.CompiledFile.source_path)
}
inline void CompiledFile::set_source_path(const char* value) {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.CompiledFile.source_path)
}
inline void CompiledFile::set_source_path(const char* value, size_t size) {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.CompiledFile.source_path)
}
inline ::std::string* CompiledFile::mutable_source_path() {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompiledFile.source_path)
  return source_path_;
}
inline ::std::string* CompiledFile::release_source_path() {
  clear_has_source_path();
  if (source_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_path_;
    source_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CompiledFile::set_allocated_source_path(::std::string* source_path) {
  if (source_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_path_;
  }
  if (source_path) {
    set_has_source_path();
    source_path_ = source_path;
  } else {
    clear_has_source_path();
    source_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompiledFile.source_path)
}

// repeated .aapt.pb.CompiledFile.Symbol exported_symbols = 4;
inline int CompiledFile::exported_symbols_size() const {
  return exported_symbols_.size();
}
inline void CompiledFile::clear_exported_symbols() {
  exported_symbols_.Clear();
}
inline const ::aapt::pb::CompiledFile_Symbol& CompiledFile::exported_symbols(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompiledFile.exported_symbols)
  return exported_symbols_.Get(index);
}
inline ::aapt::pb::CompiledFile_Symbol* CompiledFile::mutable_exported_symbols(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompiledFile.exported_symbols)
  return exported_symbols_.Mutable(index);
}
inline ::aapt::pb::CompiledFile_Symbol* CompiledFile::add_exported_symbols() {
  // @@protoc_insertion_point(field_add:aapt.pb.CompiledFile.exported_symbols)
  return exported_symbols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::CompiledFile_Symbol >&
CompiledFile::exported_symbols() const {
  // @@protoc_insertion_point(field_list:aapt.pb.CompiledFile.exported_symbols)
  return exported_symbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::CompiledFile_Symbol >*
CompiledFile::mutable_exported_symbols() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.CompiledFile.exported_symbols)
  return &exported_symbols_;
}

// -------------------------------------------------------------------

// ResourceTable

// optional .aapt.pb.StringPool string_pool = 1;
inline bool ResourceTable::has_string_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceTable::set_has_string_pool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceTable::clear_has_string_pool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceTable::clear_string_pool() {
  if (string_pool_ != NULL) string_pool_->::aapt::pb::StringPool::Clear();
  clear_has_string_pool();
}
inline const ::aapt::pb::StringPool& ResourceTable::string_pool() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.string_pool)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return string_pool_ != NULL ? *string_pool_ : *default_instance().string_pool_;
#else
  return string_pool_ != NULL ? *string_pool_ : *default_instance_->string_pool_;
#endif
}
inline ::aapt::pb::StringPool* ResourceTable::mutable_string_pool() {
  set_has_string_pool();
  if (string_pool_ == NULL) string_pool_ = new ::aapt::pb::StringPool;
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.string_pool)
  return string_pool_;
}
inline ::aapt::pb::StringPool* ResourceTable::release_string_pool() {
  clear_has_string_pool();
  ::aapt::pb::StringPool* temp = string_pool_;
  string_pool_ = NULL;
  return temp;
}
inline void ResourceTable::set_allocated_string_pool(::aapt::pb::StringPool* string_pool) {
  delete string_pool_;
  string_pool_ = string_pool;
  if (string_pool) {
    set_has_string_pool();
  } else {
    clear_has_string_pool();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ResourceTable.string_pool)
}

// optional .aapt.pb.StringPool source_pool = 2;
inline bool ResourceTable::has_source_pool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceTable::set_has_source_pool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceTable::clear_has_source_pool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceTable::clear_source_pool() {
  if (source_pool_ != NULL) source_pool_->::aapt::pb::StringPool::Clear();
  clear_has_source_pool();
}
inline const ::aapt::pb::StringPool& ResourceTable::source_pool() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.source_pool)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_pool_ != NULL ? *source_pool_ : *default_instance().source_pool_;
#else
  return source_pool_ != NULL ? *source_pool_ : *default_instance_->source_pool_;
#endif
}
inline ::aapt::pb::StringPool* ResourceTable::mutable_source_pool() {
  set_has_source_pool();
  if (source_pool_ == NULL) source_pool_ = new ::aapt::pb::StringPool;
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.source_pool)
  return source_pool_;
}
inline ::aapt::pb::StringPool* ResourceTable::release_source_pool() {
  clear_has_source_pool();
  ::aapt::pb::StringPool* temp = source_pool_;
  source_pool_ = NULL;
  return temp;
}
inline void ResourceTable::set_allocated_source_pool(::aapt::pb::StringPool* source_pool) {
  delete source_pool_;
  source_pool_ = source_pool;
  if (source_pool) {
    set_has_source_pool();
  } else {
    clear_has_source_pool();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ResourceTable.source_pool)
}

// optional .aapt.pb.StringPool symbol_pool = 3;
inline bool ResourceTable::has_symbol_pool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceTable::set_has_symbol_pool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceTable::clear_has_symbol_pool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceTable::clear_symbol_pool() {
  if (symbol_pool_ != NULL) symbol_pool_->::aapt::pb::StringPool::Clear();
  clear_has_symbol_pool();
}
inline const ::aapt::pb::StringPool& ResourceTable::symbol_pool() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.symbol_pool)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return symbol_pool_ != NULL ? *symbol_pool_ : *default_instance().symbol_pool_;
#else
  return symbol_pool_ != NULL ? *symbol_pool_ : *default_instance_->symbol_pool_;
#endif
}
inline ::aapt::pb::StringPool* ResourceTable::mutable_symbol_pool() {
  set_has_symbol_pool();
  if (symbol_pool_ == NULL) symbol_pool_ = new ::aapt::pb::StringPool;
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.symbol_pool)
  return symbol_pool_;
}
inline ::aapt::pb::StringPool* ResourceTable::release_symbol_pool() {
  clear_has_symbol_pool();
  ::aapt::pb::StringPool* temp = symbol_pool_;
  symbol_pool_ = NULL;
  return temp;
}
inline void ResourceTable::set_allocated_symbol_pool(::aapt::pb::StringPool* symbol_pool) {
  delete symbol_pool_;
  symbol_pool_ = symbol_pool;
  if (symbol_pool) {
    set_has_symbol_pool();
  } else {
    clear_has_symbol_pool();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ResourceTable.symbol_pool)
}

// repeated .aapt.pb.Package packages = 4;
inline int ResourceTable::packages_size() const {
  return packages_.size();
}
inline void ResourceTable::clear_packages() {
  packages_.Clear();
}
inline const ::aapt::pb::Package& ResourceTable::packages(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.packages)
  return packages_.Get(index);
}
inline ::aapt::pb::Package* ResourceTable::mutable_packages(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.packages)
  return packages_.Mutable(index);
}
inline ::aapt::pb::Package* ResourceTable::add_packages() {
  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.packages)
  return packages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >&
ResourceTable::packages() const {
  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.packages)
  return packages_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >*
ResourceTable::mutable_packages() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.packages)
  return &packages_;
}

// -------------------------------------------------------------------

// Package

// optional uint32 package_id = 1;
inline bool Package::has_package_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Package::set_has_package_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Package::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Package::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
inline ::google::protobuf::uint32 Package::package_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_id)
  return package_id_;
}
inline void Package::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_id)
}

// optional string package_name = 2;
inline bool Package::has_package_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Package::set_has_package_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Package::clear_has_package_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Package::clear_package_name() {
  if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_->clear();
  }
  clear_has_package_name();
}
inline const ::std::string& Package::package_name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_name)
  return *package_name_;
}
inline void Package::set_package_name(const ::std::string& value) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_name)
}
inline void Package::set_package_name(const char* value) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Package.package_name)
}
inline void Package::set_package_name(const char* value, size_t size) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Package.package_name)
}
inline ::std::string* Package::mutable_package_name() {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.package_name)
  return package_name_;
}
inline ::std::string* Package::release_package_name() {
  clear_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = package_name_;
    package_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Package::set_allocated_package_name(::std::string* package_name) {
  if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_name_;
  }
  if (package_name) {
    set_has_package_name();
    package_name_ = package_name;
  } else {
    clear_has_package_name();
    package_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Package.package_name)
}

// repeated .aapt.pb.Type types = 3;
inline int Package::types_size() const {
  return types_.size();
}
inline void Package::clear_types() {
  types_.Clear();
}
inline const ::aapt::pb::Type& Package::types(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.types)
  return types_.Get(index);
}
inline ::aapt::pb::Type* Package::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.types)
  return types_.Mutable(index);
}
inline ::aapt::pb::Type* Package::add_types() {
  // @@protoc_insertion_point(field_add:aapt.pb.Package.types)
  return types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >&
Package::types() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Package.types)
  return types_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >*
Package::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Package.types)
  return &types_;
}

// -------------------------------------------------------------------

// Type

// optional uint32 id = 1;
inline bool Type::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Type::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Type::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Type::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Type::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.id)
  return id_;
}
inline void Type::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Type.id)
}

// optional string name = 2;
inline bool Type::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Type::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Type::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Type::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.name)
  return *name_;
}
inline void Type::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Type.name)
}
inline void Type::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Type.name)
}
inline void Type::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Type.name)
}
inline ::std::string* Type::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.name)
  return name_;
}
inline ::std::string* Type::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Type::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Type.name)
}

// repeated .aapt.pb.Entry entries = 3;
inline int Type::entries_size() const {
  return entries_.size();
}
inline void Type::clear_entries() {
  entries_.Clear();
}
inline const ::aapt::pb::Entry& Type::entries(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.entries)
  return entries_.Get(index);
}
inline ::aapt::pb::Entry* Type::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.entries)
  return entries_.Mutable(index);
}
inline ::aapt::pb::Entry* Type::add_entries() {
  // @@protoc_insertion_point(field_add:aapt.pb.Type.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >&
Type::entries() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Type.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >*
Type::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Type.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// SymbolStatus

// optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
inline bool SymbolStatus::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatus::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatus::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatus::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::aapt::pb::SymbolStatus_Visibility SymbolStatus::visibility() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.visibility)
  return static_cast< ::aapt::pb::SymbolStatus_Visibility >(visibility_);
}
inline void SymbolStatus::set_visibility(::aapt::pb::SymbolStatus_Visibility value) {
  assert(::aapt::pb::SymbolStatus_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.visibility)
}

// optional .aapt.pb.Source source = 2;
inline bool SymbolStatus::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatus::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatus::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatus::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& SymbolStatus::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* SymbolStatus::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.SymbolStatus.source)
  return source_;
}
inline ::aapt::pb::Source* SymbolStatus::release_source() {
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void SymbolStatus::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.SymbolStatus.source)
}

// optional string comment = 3;
inline bool SymbolStatus::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatus::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatus::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatus::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& SymbolStatus::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.comment)
  return *comment_;
}
inline void SymbolStatus::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.comment)
}
inline void SymbolStatus::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.SymbolStatus.comment)
}
inline void SymbolStatus::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.SymbolStatus.comment)
}
inline ::std::string* SymbolStatus::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.SymbolStatus.comment)
  return comment_;
}
inline ::std::string* SymbolStatus::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SymbolStatus::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.SymbolStatus.comment)
}

// -------------------------------------------------------------------

// Entry

// optional uint32 id = 1;
inline bool Entry::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entry::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entry::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entry::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Entry::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.id)
  return id_;
}
inline void Entry::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Entry.id)
}

// optional string name = 2;
inline bool Entry::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entry::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entry::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entry::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Entry::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.name)
  return *name_;
}
inline void Entry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Entry.name)
}
inline void Entry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Entry.name)
}
inline void Entry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Entry.name)
}
inline ::std::string* Entry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.name)
  return name_;
}
inline ::std::string* Entry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Entry::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.name)
}

// optional .aapt.pb.SymbolStatus symbol_status = 3;
inline bool Entry::has_symbol_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entry::set_has_symbol_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entry::clear_has_symbol_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entry::clear_symbol_status() {
  if (symbol_status_ != NULL) symbol_status_->::aapt::pb::SymbolStatus::Clear();
  clear_has_symbol_status();
}
inline const ::aapt::pb::SymbolStatus& Entry::symbol_status() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.symbol_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return symbol_status_ != NULL ? *symbol_status_ : *default_instance().symbol_status_;
#else
  return symbol_status_ != NULL ? *symbol_status_ : *default_instance_->symbol_status_;
#endif
}
inline ::aapt::pb::SymbolStatus* Entry::mutable_symbol_status() {
  set_has_symbol_status();
  if (symbol_status_ == NULL) symbol_status_ = new ::aapt::pb::SymbolStatus;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.symbol_status)
  return symbol_status_;
}
inline ::aapt::pb::SymbolStatus* Entry::release_symbol_status() {
  clear_has_symbol_status();
  ::aapt::pb::SymbolStatus* temp = symbol_status_;
  symbol_status_ = NULL;
  return temp;
}
inline void Entry::set_allocated_symbol_status(::aapt::pb::SymbolStatus* symbol_status) {
  delete symbol_status_;
  symbol_status_ = symbol_status;
  if (symbol_status) {
    set_has_symbol_status();
  } else {
    clear_has_symbol_status();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.symbol_status)
}

// repeated .aapt.pb.ConfigValue config_values = 4;
inline int Entry::config_values_size() const {
  return config_values_.size();
}
inline void Entry::clear_config_values() {
  config_values_.Clear();
}
inline const ::aapt::pb::ConfigValue& Entry::config_values(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.config_values)
  return config_values_.Get(index);
}
inline ::aapt::pb::ConfigValue* Entry::mutable_config_values(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.config_values)
  return config_values_.Mutable(index);
}
inline ::aapt::pb::ConfigValue* Entry::add_config_values() {
  // @@protoc_insertion_point(field_add:aapt.pb.Entry.config_values)
  return config_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >&
Entry::config_values() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Entry.config_values)
  return config_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >*
Entry::mutable_config_values() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Entry.config_values)
  return &config_values_;
}

// -------------------------------------------------------------------

// ConfigValue

// optional .aapt.pb.ConfigDescription config = 1;
inline bool ConfigValue::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigValue::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigValue::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigValue::clear_config() {
  if (config_ != NULL) config_->::aapt::pb::ConfigDescription::Clear();
  clear_has_config();
}
inline const ::aapt::pb::ConfigDescription& ConfigValue::config() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::aapt::pb::ConfigDescription* ConfigValue::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::aapt::pb::ConfigDescription;
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.config)
  return config_;
}
inline ::aapt::pb::ConfigDescription* ConfigValue::release_config() {
  clear_has_config();
  ::aapt::pb::ConfigDescription* temp = config_;
  config_ = NULL;
  return temp;
}
inline void ConfigValue::set_allocated_config(::aapt::pb::ConfigDescription* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.config)
}

// optional .aapt.pb.Value value = 2;
inline bool ConfigValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigValue::clear_value() {
  if (value_ != NULL) value_->::aapt::pb::Value::Clear();
  clear_has_value();
}
inline const ::aapt::pb::Value& ConfigValue::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.value)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return value_ != NULL ? *value_ : *default_instance().value_;
#else
  return value_ != NULL ? *value_ : *default_instance_->value_;
#endif
}
inline ::aapt::pb::Value* ConfigValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::aapt::pb::Value;
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.value)
  return value_;
}
inline ::aapt::pb::Value* ConfigValue::release_value() {
  clear_has_value();
  ::aapt::pb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ConfigValue::set_allocated_value(::aapt::pb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.value)
}

// -------------------------------------------------------------------

// Source

// optional uint32 path_idx = 1;
inline bool Source::has_path_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Source::set_has_path_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Source::clear_has_path_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Source::clear_path_idx() {
  path_idx_ = 0u;
  clear_has_path_idx();
}
inline ::google::protobuf::uint32 Source::path_idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.path_idx)
  return path_idx_;
}
inline void Source::set_path_idx(::google::protobuf::uint32 value) {
  set_has_path_idx();
  path_idx_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Source.path_idx)
}

// optional uint32 line_no = 2;
inline bool Source::has_line_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Source::set_has_line_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Source::clear_has_line_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Source::clear_line_no() {
  line_no_ = 0u;
  clear_has_line_no();
}
inline ::google::protobuf::uint32 Source::line_no() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.line_no)
  return line_no_;
}
inline void Source::set_line_no(::google::protobuf::uint32 value) {
  set_has_line_no();
  line_no_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Source.line_no)
}

// optional uint32 col_no = 3;
inline bool Source::has_col_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Source::set_has_col_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Source::clear_has_col_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Source::clear_col_no() {
  col_no_ = 0u;
  clear_has_col_no();
}
inline ::google::protobuf::uint32 Source::col_no() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.col_no)
  return col_no_;
}
inline void Source::set_col_no(::google::protobuf::uint32 value) {
  set_has_col_no();
  col_no_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Source.col_no)
}

// -------------------------------------------------------------------

// Reference

// optional .aapt.pb.Reference.Type type = 1;
inline bool Reference::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reference::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reference::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reference::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::aapt::pb::Reference_Type Reference::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.type)
  return static_cast< ::aapt::pb::Reference_Type >(type_);
}
inline void Reference::set_type(::aapt::pb::Reference_Type value) {
  assert(::aapt::pb::Reference_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.type)
}

// optional uint32 id = 2;
inline bool Reference::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reference::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reference::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reference::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Reference::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.id)
  return id_;
}
inline void Reference::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.id)
}

// optional uint32 symbol_idx = 3;
inline bool Reference::has_symbol_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reference::set_has_symbol_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reference::clear_has_symbol_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reference::clear_symbol_idx() {
  symbol_idx_ = 0u;
  clear_has_symbol_idx();
}
inline ::google::protobuf::uint32 Reference::symbol_idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.symbol_idx)
  return symbol_idx_;
}
inline void Reference::set_symbol_idx(::google::protobuf::uint32 value) {
  set_has_symbol_idx();
  symbol_idx_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.symbol_idx)
}

// optional bool private = 4;
inline bool Reference::has_private_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reference::set_has_private_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reference::clear_has_private_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reference::clear_private_() {
  private__ = false;
  clear_has_private_();
}
inline bool Reference::private_() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.private)
  return private__;
}
inline void Reference::set_private_(bool value) {
  set_has_private_();
  private__ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.private)
}

// -------------------------------------------------------------------

// Id

// -------------------------------------------------------------------

// String

// optional uint32 idx = 1;
inline bool String::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void String::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void String::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void String::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 String::idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.String.idx)
  return idx_;
}
inline void String::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.String.idx)
}

// -------------------------------------------------------------------

// RawString

// optional uint32 idx = 1;
inline bool RawString::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawString::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawString::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawString::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 RawString::idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.RawString.idx)
  return idx_;
}
inline void RawString::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.RawString.idx)
}

// -------------------------------------------------------------------

// FileReference

// optional uint32 path_idx = 1;
inline bool FileReference::has_path_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileReference::set_has_path_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileReference::clear_has_path_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileReference::clear_path_idx() {
  path_idx_ = 0u;
  clear_has_path_idx();
}
inline ::google::protobuf::uint32 FileReference::path_idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.FileReference.path_idx)
  return path_idx_;
}
inline void FileReference::set_path_idx(::google::protobuf::uint32 value) {
  set_has_path_idx();
  path_idx_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.FileReference.path_idx)
}

// -------------------------------------------------------------------

// Primitive

// optional uint32 type = 1;
inline bool Primitive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Primitive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Primitive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Primitive::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Primitive::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.type)
  return type_;
}
inline void Primitive::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.type)
}

// optional uint32 data = 2;
inline bool Primitive::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Primitive::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Primitive::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Primitive::clear_data() {
  data_ = 0u;
  clear_has_data();
}
inline ::google::protobuf::uint32 Primitive::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.data)
  return data_;
}
inline void Primitive::set_data(::google::protobuf::uint32 value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.data)
}

// -------------------------------------------------------------------

// Attribute_Symbol

// optional .aapt.pb.Source source = 1;
inline bool Attribute_Symbol::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute_Symbol::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute_Symbol::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute_Symbol::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Attribute_Symbol::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Attribute_Symbol::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.source)
  return source_;
}
inline ::aapt::pb::Source* Attribute_Symbol::release_source() {
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Attribute_Symbol::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.source)
}

// optional string comment = 2;
inline bool Attribute_Symbol::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute_Symbol::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute_Symbol::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute_Symbol::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Attribute_Symbol::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.comment)
  return *comment_;
}
inline void Attribute_Symbol::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.comment)
}
inline void Attribute_Symbol::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Attribute.Symbol.comment)
}
inline void Attribute_Symbol::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Attribute.Symbol.comment)
}
inline ::std::string* Attribute_Symbol::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.comment)
  return comment_;
}
inline ::std::string* Attribute_Symbol::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Attribute_Symbol::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.comment)
}

// optional .aapt.pb.Reference name = 3;
inline bool Attribute_Symbol::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute_Symbol::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute_Symbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute_Symbol::clear_name() {
  if (name_ != NULL) name_->::aapt::pb::Reference::Clear();
  clear_has_name();
}
inline const ::aapt::pb::Reference& Attribute_Symbol::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.name)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return name_ != NULL ? *name_ : *default_instance().name_;
#else
  return name_ != NULL ? *name_ : *default_instance_->name_;
#endif
}
inline ::aapt::pb::Reference* Attribute_Symbol::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::aapt::pb::Reference;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.name)
  return name_;
}
inline ::aapt::pb::Reference* Attribute_Symbol::release_name() {
  clear_has_name();
  ::aapt::pb::Reference* temp = name_;
  name_ = NULL;
  return temp;
}
inline void Attribute_Symbol::set_allocated_name(::aapt::pb::Reference* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.name)
}

// optional uint32 value = 4;
inline bool Attribute_Symbol::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute_Symbol::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute_Symbol::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute_Symbol::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 Attribute_Symbol::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.value)
  return value_;
}
inline void Attribute_Symbol::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.value)
}

// -------------------------------------------------------------------

// Attribute

// optional uint32 format_flags = 1;
inline bool Attribute::has_format_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_format_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_format_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_format_flags() {
  format_flags_ = 0u;
  clear_has_format_flags();
}
inline ::google::protobuf::uint32 Attribute::format_flags() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.format_flags)
  return format_flags_;
}
inline void Attribute::set_format_flags(::google::protobuf::uint32 value) {
  set_has_format_flags();
  format_flags_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.format_flags)
}

// optional int32 min_int = 2;
inline bool Attribute::has_min_int() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_min_int() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_min_int() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_min_int() {
  min_int_ = 0;
  clear_has_min_int();
}
inline ::google::protobuf::int32 Attribute::min_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.min_int)
  return min_int_;
}
inline void Attribute::set_min_int(::google::protobuf::int32 value) {
  set_has_min_int();
  min_int_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.min_int)
}

// optional int32 max_int = 3;
inline bool Attribute::has_max_int() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_max_int() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_max_int() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_max_int() {
  max_int_ = 0;
  clear_has_max_int();
}
inline ::google::protobuf::int32 Attribute::max_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.max_int)
  return max_int_;
}
inline void Attribute::set_max_int(::google::protobuf::int32 value) {
  set_has_max_int();
  max_int_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.max_int)
}

// repeated .aapt.pb.Attribute.Symbol symbols = 4;
inline int Attribute::symbols_size() const {
  return symbols_.size();
}
inline void Attribute::clear_symbols() {
  symbols_.Clear();
}
inline const ::aapt::pb::Attribute_Symbol& Attribute::symbols(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.symbols)
  return symbols_.Get(index);
}
inline ::aapt::pb::Attribute_Symbol* Attribute::mutable_symbols(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.symbols)
  return symbols_.Mutable(index);
}
inline ::aapt::pb::Attribute_Symbol* Attribute::add_symbols() {
  // @@protoc_insertion_point(field_add:aapt.pb.Attribute.symbols)
  return symbols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
Attribute::symbols() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Attribute.symbols)
  return symbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
Attribute::mutable_symbols() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Attribute.symbols)
  return &symbols_;
}

// -------------------------------------------------------------------

// Style_Entry

// optional .aapt.pb.Source source = 1;
inline bool Style_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Style_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Style_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Style_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Style_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Style_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.source)
  return source_;
}
inline ::aapt::pb::Source* Style_Entry::release_source() {
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Style_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.source)
}

// optional string comment = 2;
inline bool Style_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Style_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Style_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Style_Entry::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Style_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.comment)
  return *comment_;
}
inline void Style_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Style.Entry.comment)
}
inline void Style_Entry::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Style.Entry.comment)
}
inline void Style_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Style.Entry.comment)
}
inline ::std::string* Style_Entry::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.comment)
  return comment_;
}
inline ::std::string* Style_Entry::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Style_Entry::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.comment)
}

// optional .aapt.pb.Reference key = 3;
inline bool Style_Entry::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Style_Entry::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Style_Entry::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Style_Entry::clear_key() {
  if (key_ != NULL) key_->::aapt::pb::Reference::Clear();
  clear_has_key();
}
inline const ::aapt::pb::Reference& Style_Entry::key() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_ != NULL ? *key_ : *default_instance().key_;
#else
  return key_ != NULL ? *key_ : *default_instance_->key_;
#endif
}
inline ::aapt::pb::Reference* Style_Entry::mutable_key() {
  set_has_key();
  if (key_ == NULL) key_ = new ::aapt::pb::Reference;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.key)
  return key_;
}
inline ::aapt::pb::Reference* Style_Entry::release_key() {
  clear_has_key();
  ::aapt::pb::Reference* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Style_Entry::set_allocated_key(::aapt::pb::Reference* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.key)
}

// optional .aapt.pb.Item item = 4;
inline bool Style_Entry::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Style_Entry::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Style_Entry::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Style_Entry::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Style_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Style_Entry::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::aapt::pb::Item;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.item)
  return item_;
}
inline ::aapt::pb::Item* Style_Entry::release_item() {
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Style_Entry::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.item)
}

// -------------------------------------------------------------------

// Style

// optional .aapt.pb.Reference parent = 1;
inline bool Style::has_parent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Style::set_has_parent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Style::clear_has_parent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Style::clear_parent() {
  if (parent_ != NULL) parent_->::aapt::pb::Reference::Clear();
  clear_has_parent();
}
inline const ::aapt::pb::Reference& Style::parent() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parent_ != NULL ? *parent_ : *default_instance().parent_;
#else
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
#endif
}
inline ::aapt::pb::Reference* Style::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::aapt::pb::Reference;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent)
  return parent_;
}
inline ::aapt::pb::Reference* Style::release_parent() {
  clear_has_parent();
  ::aapt::pb::Reference* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void Style::set_allocated_parent(::aapt::pb::Reference* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent)
}

// optional .aapt.pb.Source parent_source = 2;
inline bool Style::has_parent_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Style::set_has_parent_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Style::clear_has_parent_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Style::clear_parent_source() {
  if (parent_source_ != NULL) parent_source_->::aapt::pb::Source::Clear();
  clear_has_parent_source();
}
inline const ::aapt::pb::Source& Style::parent_source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent_source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parent_source_ != NULL ? *parent_source_ : *default_instance().parent_source_;
#else
  return parent_source_ != NULL ? *parent_source_ : *default_instance_->parent_source_;
#endif
}
inline ::aapt::pb::Source* Style::mutable_parent_source() {
  set_has_parent_source();
  if (parent_source_ == NULL) parent_source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent_source)
  return parent_source_;
}
inline ::aapt::pb::Source* Style::release_parent_source() {
  clear_has_parent_source();
  ::aapt::pb::Source* temp = parent_source_;
  parent_source_ = NULL;
  return temp;
}
inline void Style::set_allocated_parent_source(::aapt::pb::Source* parent_source) {
  delete parent_source_;
  parent_source_ = parent_source;
  if (parent_source) {
    set_has_parent_source();
  } else {
    clear_has_parent_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent_source)
}

// repeated .aapt.pb.Style.Entry entries = 3;
inline int Style::entries_size() const {
  return entries_.size();
}
inline void Style::clear_entries() {
  entries_.Clear();
}
inline const ::aapt::pb::Style_Entry& Style::entries(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.entries)
  return entries_.Get(index);
}
inline ::aapt::pb::Style_Entry* Style::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.entries)
  return entries_.Mutable(index);
}
inline ::aapt::pb::Style_Entry* Style::add_entries() {
  // @@protoc_insertion_point(field_add:aapt.pb.Style.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >&
Style::entries() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Style.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >*
Style::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Style.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// Styleable_Entry

// optional .aapt.pb.Source source = 1;
inline bool Styleable_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Styleable_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Styleable_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Styleable_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Styleable_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Styleable_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.source)
  return source_;
}
inline ::aapt::pb::Source* Styleable_Entry::release_source() {
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Styleable_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.source)
}

// optional string comment = 2;
inline bool Styleable_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Styleable_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Styleable_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Styleable_Entry::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Styleable_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.comment)
  return *comment_;
}
inline void Styleable_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Styleable.Entry.comment)
}
inline void Styleable_Entry::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Styleable.Entry.comment)
}
inline void Styleable_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Styleable.Entry.comment)
}
inline ::std::string* Styleable_Entry::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.comment)
  return comment_;
}
inline ::std::string* Styleable_Entry::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Styleable_Entry::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.comment)
}

// optional .aapt.pb.Reference attr = 3;
inline bool Styleable_Entry::has_attr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Styleable_Entry::set_has_attr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Styleable_Entry::clear_has_attr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Styleable_Entry::clear_attr() {
  if (attr_ != NULL) attr_->::aapt::pb::Reference::Clear();
  clear_has_attr();
}
inline const ::aapt::pb::Reference& Styleable_Entry::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.attr)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_ != NULL ? *attr_ : *default_instance().attr_;
#else
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
#endif
}
inline ::aapt::pb::Reference* Styleable_Entry::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) attr_ = new ::aapt::pb::Reference;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.attr)
  return attr_;
}
inline ::aapt::pb::Reference* Styleable_Entry::release_attr() {
  clear_has_attr();
  ::aapt::pb::Reference* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void Styleable_Entry::set_allocated_attr(::aapt::pb::Reference* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.attr)
}

// -------------------------------------------------------------------

// Styleable

// repeated .aapt.pb.Styleable.Entry entries = 1;
inline int Styleable::entries_size() const {
  return entries_.size();
}
inline void Styleable::clear_entries() {
  entries_.Clear();
}
inline const ::aapt::pb::Styleable_Entry& Styleable::entries(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.entries)
  return entries_.Get(index);
}
inline ::aapt::pb::Styleable_Entry* Styleable::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.entries)
  return entries_.Mutable(index);
}
inline ::aapt::pb::Styleable_Entry* Styleable::add_entries() {
  // @@protoc_insertion_point(field_add:aapt.pb.Styleable.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
Styleable::entries() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Styleable.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
Styleable::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Styleable.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// Array_Entry

// optional .aapt.pb.Source source = 1;
inline bool Array_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Array_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Array_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Array_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Array_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Array_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Entry.source)
  return source_;
}
inline ::aapt::pb::Source* Array_Entry::release_source() {
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Array_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Entry.source)
}

// optional string comment = 2;
inline bool Array_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Array_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Array_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Array_Entry::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Array_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Entry.comment)
  return *comment_;
}
inline void Array_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Array.Entry.comment)
}
inline void Array_Entry::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Array.Entry.comment)
}
inline void Array_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Array.Entry.comment)
}
inline ::std::string* Array_Entry::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Entry.comment)
  return comment_;
}
inline ::std::string* Array_Entry::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Array_Entry::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Entry.comment)
}

// optional .aapt.pb.Item item = 3;
inline bool Array_Entry::has_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Array_Entry::set_has_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Array_Entry::clear_has_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Array_Entry::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Array_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Entry.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Array_Entry::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::aapt::pb::Item;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Entry.item)
  return item_;
}
inline ::aapt::pb::Item* Array_Entry::release_item() {
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Array_Entry::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Entry.item)
}

// -------------------------------------------------------------------

// Array

// repeated .aapt.pb.Array.Entry entries = 1;
inline int Array::entries_size() const {
  return entries_.size();
}
inline void Array::clear_entries() {
  entries_.Clear();
}
inline const ::aapt::pb::Array_Entry& Array::entries(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.entries)
  return entries_.Get(index);
}
inline ::aapt::pb::Array_Entry* Array::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.entries)
  return entries_.Mutable(index);
}
inline ::aapt::pb::Array_Entry* Array::add_entries() {
  // @@protoc_insertion_point(field_add:aapt.pb.Array.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Entry >&
Array::entries() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Array.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Entry >*
Array::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Array.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// Plural_Entry

// optional .aapt.pb.Source source = 1;
inline bool Plural_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plural_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plural_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plural_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Plural_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Plural_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.source)
  return source_;
}
inline ::aapt::pb::Source* Plural_Entry::release_source() {
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Plural_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.source)
}

// optional string comment = 2;
inline bool Plural_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plural_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plural_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plural_Entry::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Plural_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.comment)
  return *comment_;
}
inline void Plural_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.comment)
}
inline void Plural_Entry::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Plural.Entry.comment)
}
inline void Plural_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Plural.Entry.comment)
}
inline ::std::string* Plural_Entry::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.comment)
  return comment_;
}
inline ::std::string* Plural_Entry::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Plural_Entry::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.comment)
}

// optional .aapt.pb.Plural.Arity arity = 3;
inline bool Plural_Entry::has_arity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plural_Entry::set_has_arity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Plural_Entry::clear_has_arity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Plural_Entry::clear_arity() {
  arity_ = 0;
  clear_has_arity();
}
inline ::aapt::pb::Plural_Arity Plural_Entry::arity() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.arity)
  return static_cast< ::aapt::pb::Plural_Arity >(arity_);
}
inline void Plural_Entry::set_arity(::aapt::pb::Plural_Arity value) {
  assert(::aapt::pb::Plural_Arity_IsValid(value));
  set_has_arity();
  arity_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.arity)
}

// optional .aapt.pb.Item item = 4;
inline bool Plural_Entry::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Plural_Entry::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Plural_Entry::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Plural_Entry::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Plural_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Plural_Entry::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::aapt::pb::Item;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.item)
  return item_;
}
inline ::aapt::pb::Item* Plural_Entry::release_item() {
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Plural_Entry::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.item)
}

// -------------------------------------------------------------------

// Plural

// repeated .aapt.pb.Plural.Entry entries = 1;
inline int Plural::entries_size() const {
  return entries_.size();
}
inline void Plural::clear_entries() {
  entries_.Clear();
}
inline const ::aapt::pb::Plural_Entry& Plural::entries(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.entries)
  return entries_.Get(index);
}
inline ::aapt::pb::Plural_Entry* Plural::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.entries)
  return entries_.Mutable(index);
}
inline ::aapt::pb::Plural_Entry* Plural::add_entries() {
  // @@protoc_insertion_point(field_add:aapt.pb.Plural.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
Plural::entries() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Plural.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
Plural::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Plural.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// Item

// optional .aapt.pb.Reference ref = 1;
inline bool Item::has_ref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_ref() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_ref() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_ref() {
  if (ref_ != NULL) ref_->::aapt::pb::Reference::Clear();
  clear_has_ref();
}
inline const ::aapt::pb::Reference& Item::ref() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.ref)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ref_ != NULL ? *ref_ : *default_instance().ref_;
#else
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
#endif
}
inline ::aapt::pb::Reference* Item::mutable_ref() {
  set_has_ref();
  if (ref_ == NULL) ref_ = new ::aapt::pb::Reference;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.ref)
  return ref_;
}
inline ::aapt::pb::Reference* Item::release_ref() {
  clear_has_ref();
  ::aapt::pb::Reference* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void Item::set_allocated_ref(::aapt::pb::Reference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    set_has_ref();
  } else {
    clear_has_ref();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.ref)
}

// optional .aapt.pb.String str = 2;
inline bool Item::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item::clear_str() {
  if (str_ != NULL) str_->::aapt::pb::String::Clear();
  clear_has_str();
}
inline const ::aapt::pb::String& Item::str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return str_ != NULL ? *str_ : *default_instance().str_;
#else
  return str_ != NULL ? *str_ : *default_instance_->str_;
#endif
}
inline ::aapt::pb::String* Item::mutable_str() {
  set_has_str();
  if (str_ == NULL) str_ = new ::aapt::pb::String;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.str)
  return str_;
}
inline ::aapt::pb::String* Item::release_str() {
  clear_has_str();
  ::aapt::pb::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline void Item::set_allocated_str(::aapt::pb::String* str) {
  delete str_;
  str_ = str;
  if (str) {
    set_has_str();
  } else {
    clear_has_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.str)
}

// optional .aapt.pb.RawString raw_str = 3;
inline bool Item::has_raw_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item::set_has_raw_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item::clear_has_raw_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item::clear_raw_str() {
  if (raw_str_ != NULL) raw_str_->::aapt::pb::RawString::Clear();
  clear_has_raw_str();
}
inline const ::aapt::pb::RawString& Item::raw_str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.raw_str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return raw_str_ != NULL ? *raw_str_ : *default_instance().raw_str_;
#else
  return raw_str_ != NULL ? *raw_str_ : *default_instance_->raw_str_;
#endif
}
inline ::aapt::pb::RawString* Item::mutable_raw_str() {
  set_has_raw_str();
  if (raw_str_ == NULL) raw_str_ = new ::aapt::pb::RawString;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.raw_str)
  return raw_str_;
}
inline ::aapt::pb::RawString* Item::release_raw_str() {
  clear_has_raw_str();
  ::aapt::pb::RawString* temp = raw_str_;
  raw_str_ = NULL;
  return temp;
}
inline void Item::set_allocated_raw_str(::aapt::pb::RawString* raw_str) {
  delete raw_str_;
  raw_str_ = raw_str;
  if (raw_str) {
    set_has_raw_str();
  } else {
    clear_has_raw_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.raw_str)
}

// optional .aapt.pb.FileReference file = 4;
inline bool Item::has_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item::set_has_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item::clear_has_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item::clear_file() {
  if (file_ != NULL) file_->::aapt::pb::FileReference::Clear();
  clear_has_file();
}
inline const ::aapt::pb::FileReference& Item::file() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.file)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return file_ != NULL ? *file_ : *default_instance().file_;
#else
  return file_ != NULL ? *file_ : *default_instance_->file_;
#endif
}
inline ::aapt::pb::FileReference* Item::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::aapt::pb::FileReference;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.file)
  return file_;
}
inline ::aapt::pb::FileReference* Item::release_file() {
  clear_has_file();
  ::aapt::pb::FileReference* temp = file_;
  file_ = NULL;
  return temp;
}
inline void Item::set_allocated_file(::aapt::pb::FileReference* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.file)
}

// optional .aapt.pb.Id id = 5;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item::clear_id() {
  if (id_ != NULL) id_->::aapt::pb::Id::Clear();
  clear_has_id();
}
inline const ::aapt::pb::Id& Item::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aapt::pb::Id* Item::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::aapt::pb::Id;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.id)
  return id_;
}
inline ::aapt::pb::Id* Item::release_id() {
  clear_has_id();
  ::aapt::pb::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Item::set_allocated_id(::aapt::pb::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.id)
}

// optional .aapt.pb.Primitive prim = 6;
inline bool Item::has_prim() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Item::set_has_prim() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Item::clear_has_prim() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Item::clear_prim() {
  if (prim_ != NULL) prim_->::aapt::pb::Primitive::Clear();
  clear_has_prim();
}
inline const ::aapt::pb::Primitive& Item::prim() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.prim)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return prim_ != NULL ? *prim_ : *default_instance().prim_;
#else
  return prim_ != NULL ? *prim_ : *default_instance_->prim_;
#endif
}
inline ::aapt::pb::Primitive* Item::mutable_prim() {
  set_has_prim();
  if (prim_ == NULL) prim_ = new ::aapt::pb::Primitive;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.prim)
  return prim_;
}
inline ::aapt::pb::Primitive* Item::release_prim() {
  clear_has_prim();
  ::aapt::pb::Primitive* temp = prim_;
  prim_ = NULL;
  return temp;
}
inline void Item::set_allocated_prim(::aapt::pb::Primitive* prim) {
  delete prim_;
  prim_ = prim;
  if (prim) {
    set_has_prim();
  } else {
    clear_has_prim();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.prim)
}

// -------------------------------------------------------------------

// CompoundValue

// optional .aapt.pb.Attribute attr = 1;
inline bool CompoundValue::has_attr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompoundValue::set_has_attr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompoundValue::clear_has_attr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompoundValue::clear_attr() {
  if (attr_ != NULL) attr_->::aapt::pb::Attribute::Clear();
  clear_has_attr();
}
inline const ::aapt::pb::Attribute& CompoundValue::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.attr)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_ != NULL ? *attr_ : *default_instance().attr_;
#else
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
#endif
}
inline ::aapt::pb::Attribute* CompoundValue::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) attr_ = new ::aapt::pb::Attribute;
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.attr)
  return attr_;
}
inline ::aapt::pb::Attribute* CompoundValue::release_attr() {
  clear_has_attr();
  ::aapt::pb::Attribute* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_attr(::aapt::pb::Attribute* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.attr)
}

// optional .aapt.pb.Style style = 2;
inline bool CompoundValue::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompoundValue::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompoundValue::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompoundValue::clear_style() {
  if (style_ != NULL) style_->::aapt::pb::Style::Clear();
  clear_has_style();
}
inline const ::aapt::pb::Style& CompoundValue::style() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.style)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return style_ != NULL ? *style_ : *default_instance().style_;
#else
  return style_ != NULL ? *style_ : *default_instance_->style_;
#endif
}
inline ::aapt::pb::Style* CompoundValue::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::aapt::pb::Style;
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.style)
  return style_;
}
inline ::aapt::pb::Style* CompoundValue::release_style() {
  clear_has_style();
  ::aapt::pb::Style* temp = style_;
  style_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_style(::aapt::pb::Style* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.style)
}

// optional .aapt.pb.Styleable styleable = 3;
inline bool CompoundValue::has_styleable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompoundValue::set_has_styleable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompoundValue::clear_has_styleable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompoundValue::clear_styleable() {
  if (styleable_ != NULL) styleable_->::aapt::pb::Styleable::Clear();
  clear_has_styleable();
}
inline const ::aapt::pb::Styleable& CompoundValue::styleable() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.styleable)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return styleable_ != NULL ? *styleable_ : *default_instance().styleable_;
#else
  return styleable_ != NULL ? *styleable_ : *default_instance_->styleable_;
#endif
}
inline ::aapt::pb::Styleable* CompoundValue::mutable_styleable() {
  set_has_styleable();
  if (styleable_ == NULL) styleable_ = new ::aapt::pb::Styleable;
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.styleable)
  return styleable_;
}
inline ::aapt::pb::Styleable* CompoundValue::release_styleable() {
  clear_has_styleable();
  ::aapt::pb::Styleable* temp = styleable_;
  styleable_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_styleable(::aapt::pb::Styleable* styleable) {
  delete styleable_;
  styleable_ = styleable;
  if (styleable) {
    set_has_styleable();
  } else {
    clear_has_styleable();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.styleable)
}

// optional .aapt.pb.Array array = 4;
inline bool CompoundValue::has_array() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CompoundValue::set_has_array() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CompoundValue::clear_has_array() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CompoundValue::clear_array() {
  if (array_ != NULL) array_->::aapt::pb::Array::Clear();
  clear_has_array();
}
inline const ::aapt::pb::Array& CompoundValue::array() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.array)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return array_ != NULL ? *array_ : *default_instance().array_;
#else
  return array_ != NULL ? *array_ : *default_instance_->array_;
#endif
}
inline ::aapt::pb::Array* CompoundValue::mutable_array() {
  set_has_array();
  if (array_ == NULL) array_ = new ::aapt::pb::Array;
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.array)
  return array_;
}
inline ::aapt::pb::Array* CompoundValue::release_array() {
  clear_has_array();
  ::aapt::pb::Array* temp = array_;
  array_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_array(::aapt::pb::Array* array) {
  delete array_;
  array_ = array;
  if (array) {
    set_has_array();
  } else {
    clear_has_array();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.array)
}

// optional .aapt.pb.Plural plural = 5;
inline bool CompoundValue::has_plural() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CompoundValue::set_has_plural() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CompoundValue::clear_has_plural() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CompoundValue::clear_plural() {
  if (plural_ != NULL) plural_->::aapt::pb::Plural::Clear();
  clear_has_plural();
}
inline const ::aapt::pb::Plural& CompoundValue::plural() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.plural)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return plural_ != NULL ? *plural_ : *default_instance().plural_;
#else
  return plural_ != NULL ? *plural_ : *default_instance_->plural_;
#endif
}
inline ::aapt::pb::Plural* CompoundValue::mutable_plural() {
  set_has_plural();
  if (plural_ == NULL) plural_ = new ::aapt::pb::Plural;
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.plural)
  return plural_;
}
inline ::aapt::pb::Plural* CompoundValue::release_plural() {
  clear_has_plural();
  ::aapt::pb::Plural* temp = plural_;
  plural_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_plural(::aapt::pb::Plural* plural) {
  delete plural_;
  plural_ = plural;
  if (plural) {
    set_has_plural();
  } else {
    clear_has_plural();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.plural)
}

// -------------------------------------------------------------------

// Value

// optional .aapt.pb.Source source = 1;
inline bool Value::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Value::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Value::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::aapt::pb::Source;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.source)
  return source_;
}
inline ::aapt::pb::Source* Value::release_source() {
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Value::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.source)
}

// optional string comment = 2;
inline bool Value::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Value::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.comment)
  return *comment_;
}
inline void Value::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:aapt.pb.Value.comment)
}
inline void Value::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:aapt.pb.Value.comment)
}
inline void Value::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Value.comment)
}
inline ::std::string* Value::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.comment)
  return comment_;
}
inline ::std::string* Value::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Value::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.comment)
}

// optional bool weak = 3;
inline bool Value::has_weak() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_weak() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_weak() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_weak() {
  weak_ = false;
  clear_has_weak();
}
inline bool Value::weak() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.weak)
  return weak_;
}
inline void Value::set_weak(bool value) {
  set_has_weak();
  weak_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Value.weak)
}

// optional .aapt.pb.Item item = 4;
inline bool Value::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Value::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Value::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::aapt::pb::Item;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.item)
  return item_;
}
inline ::aapt::pb::Item* Value::release_item() {
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Value::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.item)
}

// optional .aapt.pb.CompoundValue compound_value = 5;
inline bool Value::has_compound_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_compound_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_compound_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_compound_value() {
  if (compound_value_ != NULL) compound_value_->::aapt::pb::CompoundValue::Clear();
  clear_has_compound_value();
}
inline const ::aapt::pb::CompoundValue& Value::compound_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.compound_value)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return compound_value_ != NULL ? *compound_value_ : *default_instance().compound_value_;
#else
  return compound_value_ != NULL ? *compound_value_ : *default_instance_->compound_value_;
#endif
}
inline ::aapt::pb::CompoundValue* Value::mutable_compound_value() {
  set_has_compound_value();
  if (compound_value_ == NULL) compound_value_ = new ::aapt::pb::CompoundValue;
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.compound_value)
  return compound_value_;
}
inline ::aapt::pb::CompoundValue* Value::release_compound_value() {
  clear_has_compound_value();
  ::aapt::pb::CompoundValue* temp = compound_value_;
  compound_value_ = NULL;
  return temp;
}
inline void Value::set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value) {
  delete compound_value_;
  compound_value_ = compound_value;
  if (compound_value) {
    set_has_compound_value();
  } else {
    clear_has_compound_value();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.compound_value)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace aapt

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Format_2eproto__INCLUDED
