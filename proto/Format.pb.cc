// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Format.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Format.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace aapt {
namespace pb {

void protobuf_ShutdownFile_Format_2eproto() {
  delete ConfigDescription::default_instance_;
  delete StringPool::default_instance_;
  delete CompiledFile::default_instance_;
  delete CompiledFile_Symbol::default_instance_;
  delete ResourceTable::default_instance_;
  delete Package::default_instance_;
  delete Type::default_instance_;
  delete SymbolStatus::default_instance_;
  delete Entry::default_instance_;
  delete ConfigValue::default_instance_;
  delete Source::default_instance_;
  delete Reference::default_instance_;
  delete Id::default_instance_;
  delete String::default_instance_;
  delete RawString::default_instance_;
  delete FileReference::default_instance_;
  delete Primitive::default_instance_;
  delete Attribute::default_instance_;
  delete Attribute_Symbol::default_instance_;
  delete Style::default_instance_;
  delete Style_Entry::default_instance_;
  delete Styleable::default_instance_;
  delete Styleable_Entry::default_instance_;
  delete Array::default_instance_;
  delete Array_Entry::default_instance_;
  delete Plural::default_instance_;
  delete Plural_Entry::default_instance_;
  delete Item::default_instance_;
  delete CompoundValue::default_instance_;
  delete Value::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Format_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Format_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ConfigDescription::default_instance_ = new ConfigDescription();
  StringPool::default_instance_ = new StringPool();
  CompiledFile::default_instance_ = new CompiledFile();
  CompiledFile_Symbol::default_instance_ = new CompiledFile_Symbol();
  ResourceTable::default_instance_ = new ResourceTable();
  Package::default_instance_ = new Package();
  Type::default_instance_ = new Type();
  SymbolStatus::default_instance_ = new SymbolStatus();
  Entry::default_instance_ = new Entry();
  ConfigValue::default_instance_ = new ConfigValue();
  Source::default_instance_ = new Source();
  Reference::default_instance_ = new Reference();
  Id::default_instance_ = new Id();
  String::default_instance_ = new String();
  RawString::default_instance_ = new RawString();
  FileReference::default_instance_ = new FileReference();
  Primitive::default_instance_ = new Primitive();
  Attribute::default_instance_ = new Attribute();
  Attribute_Symbol::default_instance_ = new Attribute_Symbol();
  Style::default_instance_ = new Style();
  Style_Entry::default_instance_ = new Style_Entry();
  Styleable::default_instance_ = new Styleable();
  Styleable_Entry::default_instance_ = new Styleable_Entry();
  Array::default_instance_ = new Array();
  Array_Entry::default_instance_ = new Array_Entry();
  Plural::default_instance_ = new Plural();
  Plural_Entry::default_instance_ = new Plural_Entry();
  Item::default_instance_ = new Item();
  CompoundValue::default_instance_ = new CompoundValue();
  Value::default_instance_ = new Value();
  ConfigDescription::default_instance_->InitAsDefaultInstance();
  StringPool::default_instance_->InitAsDefaultInstance();
  CompiledFile::default_instance_->InitAsDefaultInstance();
  CompiledFile_Symbol::default_instance_->InitAsDefaultInstance();
  ResourceTable::default_instance_->InitAsDefaultInstance();
  Package::default_instance_->InitAsDefaultInstance();
  Type::default_instance_->InitAsDefaultInstance();
  SymbolStatus::default_instance_->InitAsDefaultInstance();
  Entry::default_instance_->InitAsDefaultInstance();
  ConfigValue::default_instance_->InitAsDefaultInstance();
  Source::default_instance_->InitAsDefaultInstance();
  Reference::default_instance_->InitAsDefaultInstance();
  Id::default_instance_->InitAsDefaultInstance();
  String::default_instance_->InitAsDefaultInstance();
  RawString::default_instance_->InitAsDefaultInstance();
  FileReference::default_instance_->InitAsDefaultInstance();
  Primitive::default_instance_->InitAsDefaultInstance();
  Attribute::default_instance_->InitAsDefaultInstance();
  Attribute_Symbol::default_instance_->InitAsDefaultInstance();
  Style::default_instance_->InitAsDefaultInstance();
  Style_Entry::default_instance_->InitAsDefaultInstance();
  Styleable::default_instance_->InitAsDefaultInstance();
  Styleable_Entry::default_instance_->InitAsDefaultInstance();
  Array::default_instance_->InitAsDefaultInstance();
  Array_Entry::default_instance_->InitAsDefaultInstance();
  Plural::default_instance_->InitAsDefaultInstance();
  Plural_Entry::default_instance_->InitAsDefaultInstance();
  Item::default_instance_->InitAsDefaultInstance();
  CompoundValue::default_instance_->InitAsDefaultInstance();
  Value::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Format_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Format_2eproto_once_);
void protobuf_AddDesc_Format_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Format_2eproto_once_,
                 &protobuf_AddDesc_Format_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Format_2eproto {
  StaticDescriptorInitializer_Format_2eproto() {
    protobuf_AddDesc_Format_2eproto();
  }
} static_descriptor_initializer_Format_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int ConfigDescription::kDataFieldNumber;
const int ConfigDescription::kProductFieldNumber;
#endif  // !_MSC_VER

ConfigDescription::ConfigDescription()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.ConfigDescription)
}

void ConfigDescription::InitAsDefaultInstance() {
}

ConfigDescription::ConfigDescription(const ConfigDescription& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.ConfigDescription)
}

void ConfigDescription::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigDescription::~ConfigDescription() {
  // @@protoc_insertion_point(destructor:aapt.pb.ConfigDescription)
  SharedDtor();
}

void ConfigDescription::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigDescription::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigDescription& ConfigDescription::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

ConfigDescription* ConfigDescription::default_instance_ = NULL;

ConfigDescription* ConfigDescription::New() const {
  return new ConfigDescription;
}

void ConfigDescription::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
    if (has_product()) {
      if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        product_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConfigDescription::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.ConfigDescription)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_product;
        break;
      }

      // optional string product = 2;
      case 2: {
        if (tag == 18) {
         parse_product:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_product()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.ConfigDescription)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.ConfigDescription)
  return false;
#undef DO_
}

void ConfigDescription::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.ConfigDescription)
  // optional bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  // optional string product = 2;
  if (has_product()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->product(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.ConfigDescription)
}

int ConfigDescription::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional string product = 2;
    if (has_product()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->product());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigDescription::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigDescription*>(&from));
}

void ConfigDescription::MergeFrom(const ConfigDescription& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_product()) {
      set_product(from.product());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConfigDescription::CopyFrom(const ConfigDescription& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigDescription::IsInitialized() const {

  return true;
}

void ConfigDescription::Swap(ConfigDescription* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(product_, other->product_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigDescription::GetTypeName() const {
  return "aapt.pb.ConfigDescription";
}


// ===================================================================

#ifndef _MSC_VER
const int StringPool::kDataFieldNumber;
#endif  // !_MSC_VER

StringPool::StringPool()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.StringPool)
}

void StringPool::InitAsDefaultInstance() {
}

StringPool::StringPool(const StringPool& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.StringPool)
}

void StringPool::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StringPool::~StringPool() {
  // @@protoc_insertion_point(destructor:aapt.pb.StringPool)
  SharedDtor();
}

void StringPool::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StringPool::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringPool& StringPool::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

StringPool* StringPool::default_instance_ = NULL;

StringPool* StringPool::New() const {
  return new StringPool;
}

void StringPool::Clear() {
  if (has_data()) {
    if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      data_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StringPool::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.StringPool)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.StringPool)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.StringPool)
  return false;
#undef DO_
}

void StringPool::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.StringPool)
  // optional bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.StringPool)
}

int StringPool::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringPool::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringPool*>(&from));
}

void StringPool::MergeFrom(const StringPool& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StringPool::CopyFrom(const StringPool& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringPool::IsInitialized() const {

  return true;
}

void StringPool::Swap(StringPool* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StringPool::GetTypeName() const {
  return "aapt.pb.StringPool";
}


// ===================================================================

#ifndef _MSC_VER
const int CompiledFile_Symbol::kResourceNameFieldNumber;
const int CompiledFile_Symbol::kLineNoFieldNumber;
#endif  // !_MSC_VER

CompiledFile_Symbol::CompiledFile_Symbol()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.CompiledFile.Symbol)
}

void CompiledFile_Symbol::InitAsDefaultInstance() {
}

CompiledFile_Symbol::CompiledFile_Symbol(const CompiledFile_Symbol& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.CompiledFile.Symbol)
}

void CompiledFile_Symbol::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  resource_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  line_no_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CompiledFile_Symbol::~CompiledFile_Symbol() {
  // @@protoc_insertion_point(destructor:aapt.pb.CompiledFile.Symbol)
  SharedDtor();
}

void CompiledFile_Symbol::SharedDtor() {
  if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resource_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CompiledFile_Symbol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CompiledFile_Symbol& CompiledFile_Symbol::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

CompiledFile_Symbol* CompiledFile_Symbol::default_instance_ = NULL;

CompiledFile_Symbol* CompiledFile_Symbol::New() const {
  return new CompiledFile_Symbol;
}

void CompiledFile_Symbol::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_resource_name()) {
      if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        resource_name_->clear();
      }
    }
    line_no_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CompiledFile_Symbol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.CompiledFile.Symbol)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string resource_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_line_no;
        break;
      }

      // optional uint32 line_no = 2;
      case 2: {
        if (tag == 16) {
         parse_line_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &line_no_)));
          set_has_line_no();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.CompiledFile.Symbol)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.CompiledFile.Symbol)
  return false;
#undef DO_
}

void CompiledFile_Symbol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.CompiledFile.Symbol)
  // optional string resource_name = 1;
  if (has_resource_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->resource_name(), output);
  }

  // optional uint32 line_no = 2;
  if (has_line_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->line_no(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.CompiledFile.Symbol)
}

int CompiledFile_Symbol::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string resource_name = 1;
    if (has_resource_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource_name());
    }

    // optional uint32 line_no = 2;
    if (has_line_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->line_no());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CompiledFile_Symbol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CompiledFile_Symbol*>(&from));
}

void CompiledFile_Symbol::MergeFrom(const CompiledFile_Symbol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resource_name()) {
      set_resource_name(from.resource_name());
    }
    if (from.has_line_no()) {
      set_line_no(from.line_no());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CompiledFile_Symbol::CopyFrom(const CompiledFile_Symbol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompiledFile_Symbol::IsInitialized() const {

  return true;
}

void CompiledFile_Symbol::Swap(CompiledFile_Symbol* other) {
  if (other != this) {
    std::swap(resource_name_, other->resource_name_);
    std::swap(line_no_, other->line_no_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CompiledFile_Symbol::GetTypeName() const {
  return "aapt.pb.CompiledFile.Symbol";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CompiledFile::kResourceNameFieldNumber;
const int CompiledFile::kConfigFieldNumber;
const int CompiledFile::kSourcePathFieldNumber;
const int CompiledFile::kExportedSymbolsFieldNumber;
#endif  // !_MSC_VER

CompiledFile::CompiledFile()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.CompiledFile)
}

void CompiledFile::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::aapt::pb::ConfigDescription*>(
      ::aapt::pb::ConfigDescription::internal_default_instance());
#else
  config_ = const_cast< ::aapt::pb::ConfigDescription*>(&::aapt::pb::ConfigDescription::default_instance());
#endif
}

CompiledFile::CompiledFile(const CompiledFile& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.CompiledFile)
}

void CompiledFile::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  resource_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  config_ = NULL;
  source_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CompiledFile::~CompiledFile() {
  // @@protoc_insertion_point(destructor:aapt.pb.CompiledFile)
  SharedDtor();
}

void CompiledFile::SharedDtor() {
  if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resource_name_;
  }
  if (source_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_path_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete config_;
  }
}

void CompiledFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CompiledFile& CompiledFile::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

CompiledFile* CompiledFile::default_instance_ = NULL;

CompiledFile* CompiledFile::New() const {
  return new CompiledFile;
}

void CompiledFile::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_resource_name()) {
      if (resource_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        resource_name_->clear();
      }
    }
    if (has_config()) {
      if (config_ != NULL) config_->::aapt::pb::ConfigDescription::Clear();
    }
    if (has_source_path()) {
      if (source_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        source_path_->clear();
      }
    }
  }
  exported_symbols_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CompiledFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.CompiledFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string resource_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_config;
        break;
      }

      // optional .aapt.pb.ConfigDescription config = 2;
      case 2: {
        if (tag == 18) {
         parse_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source_path;
        break;
      }

      // optional string source_path = 3;
      case 3: {
        if (tag == 26) {
         parse_source_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_source_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_exported_symbols;
        break;
      }

      // repeated .aapt.pb.CompiledFile.Symbol exported_symbols = 4;
      case 4: {
        if (tag == 34) {
         parse_exported_symbols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exported_symbols()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_exported_symbols;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.CompiledFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.CompiledFile)
  return false;
#undef DO_
}

void CompiledFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.CompiledFile)
  // optional string resource_name = 1;
  if (has_resource_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->resource_name(), output);
  }

  // optional .aapt.pb.ConfigDescription config = 2;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->config(), output);
  }

  // optional string source_path = 3;
  if (has_source_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->source_path(), output);
  }

  // repeated .aapt.pb.CompiledFile.Symbol exported_symbols = 4;
  for (int i = 0; i < this->exported_symbols_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->exported_symbols(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.CompiledFile)
}

int CompiledFile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string resource_name = 1;
    if (has_resource_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource_name());
    }

    // optional .aapt.pb.ConfigDescription config = 2;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->config());
    }

    // optional string source_path = 3;
    if (has_source_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->source_path());
    }

  }
  // repeated .aapt.pb.CompiledFile.Symbol exported_symbols = 4;
  total_size += 1 * this->exported_symbols_size();
  for (int i = 0; i < this->exported_symbols_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exported_symbols(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CompiledFile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CompiledFile*>(&from));
}

void CompiledFile::MergeFrom(const CompiledFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  exported_symbols_.MergeFrom(from.exported_symbols_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resource_name()) {
      set_resource_name(from.resource_name());
    }
    if (from.has_config()) {
      mutable_config()->::aapt::pb::ConfigDescription::MergeFrom(from.config());
    }
    if (from.has_source_path()) {
      set_source_path(from.source_path());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CompiledFile::CopyFrom(const CompiledFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompiledFile::IsInitialized() const {

  return true;
}

void CompiledFile::Swap(CompiledFile* other) {
  if (other != this) {
    std::swap(resource_name_, other->resource_name_);
    std::swap(config_, other->config_);
    std::swap(source_path_, other->source_path_);
    exported_symbols_.Swap(&other->exported_symbols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CompiledFile::GetTypeName() const {
  return "aapt.pb.CompiledFile";
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceTable::kStringPoolFieldNumber;
const int ResourceTable::kSourcePoolFieldNumber;
const int ResourceTable::kSymbolPoolFieldNumber;
const int ResourceTable::kPackagesFieldNumber;
#endif  // !_MSC_VER

ResourceTable::ResourceTable()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.ResourceTable)
}

void ResourceTable::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  string_pool_ = const_cast< ::aapt::pb::StringPool*>(
      ::aapt::pb::StringPool::internal_default_instance());
#else
  string_pool_ = const_cast< ::aapt::pb::StringPool*>(&::aapt::pb::StringPool::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_pool_ = const_cast< ::aapt::pb::StringPool*>(
      ::aapt::pb::StringPool::internal_default_instance());
#else
  source_pool_ = const_cast< ::aapt::pb::StringPool*>(&::aapt::pb::StringPool::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  symbol_pool_ = const_cast< ::aapt::pb::StringPool*>(
      ::aapt::pb::StringPool::internal_default_instance());
#else
  symbol_pool_ = const_cast< ::aapt::pb::StringPool*>(&::aapt::pb::StringPool::default_instance());
#endif
}

ResourceTable::ResourceTable(const ResourceTable& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.ResourceTable)
}

void ResourceTable::SharedCtor() {
  _cached_size_ = 0;
  string_pool_ = NULL;
  source_pool_ = NULL;
  symbol_pool_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceTable::~ResourceTable() {
  // @@protoc_insertion_point(destructor:aapt.pb.ResourceTable)
  SharedDtor();
}

void ResourceTable::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete string_pool_;
    delete source_pool_;
    delete symbol_pool_;
  }
}

void ResourceTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResourceTable& ResourceTable::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

ResourceTable* ResourceTable::default_instance_ = NULL;

ResourceTable* ResourceTable::New() const {
  return new ResourceTable;
}

void ResourceTable::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_string_pool()) {
      if (string_pool_ != NULL) string_pool_->::aapt::pb::StringPool::Clear();
    }
    if (has_source_pool()) {
      if (source_pool_ != NULL) source_pool_->::aapt::pb::StringPool::Clear();
    }
    if (has_symbol_pool()) {
      if (symbol_pool_ != NULL) symbol_pool_->::aapt::pb::StringPool::Clear();
    }
  }
  packages_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ResourceTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.ResourceTable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.StringPool string_pool = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_string_pool()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_source_pool;
        break;
      }

      // optional .aapt.pb.StringPool source_pool = 2;
      case 2: {
        if (tag == 18) {
         parse_source_pool:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source_pool()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_symbol_pool;
        break;
      }

      // optional .aapt.pb.StringPool symbol_pool = 3;
      case 3: {
        if (tag == 26) {
         parse_symbol_pool:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_symbol_pool()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_packages;
        break;
      }

      // repeated .aapt.pb.Package packages = 4;
      case 4: {
        if (tag == 34) {
         parse_packages:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_packages()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_packages;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.ResourceTable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.ResourceTable)
  return false;
#undef DO_
}

void ResourceTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.ResourceTable)
  // optional .aapt.pb.StringPool string_pool = 1;
  if (has_string_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->string_pool(), output);
  }

  // optional .aapt.pb.StringPool source_pool = 2;
  if (has_source_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->source_pool(), output);
  }

  // optional .aapt.pb.StringPool symbol_pool = 3;
  if (has_symbol_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->symbol_pool(), output);
  }

  // repeated .aapt.pb.Package packages = 4;
  for (int i = 0; i < this->packages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->packages(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.ResourceTable)
}

int ResourceTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.StringPool string_pool = 1;
    if (has_string_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->string_pool());
    }

    // optional .aapt.pb.StringPool source_pool = 2;
    if (has_source_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source_pool());
    }

    // optional .aapt.pb.StringPool symbol_pool = 3;
    if (has_symbol_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->symbol_pool());
    }

  }
  // repeated .aapt.pb.Package packages = 4;
  total_size += 1 * this->packages_size();
  for (int i = 0; i < this->packages_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->packages(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceTable::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResourceTable*>(&from));
}

void ResourceTable::MergeFrom(const ResourceTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  packages_.MergeFrom(from.packages_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_string_pool()) {
      mutable_string_pool()->::aapt::pb::StringPool::MergeFrom(from.string_pool());
    }
    if (from.has_source_pool()) {
      mutable_source_pool()->::aapt::pb::StringPool::MergeFrom(from.source_pool());
    }
    if (from.has_symbol_pool()) {
      mutable_symbol_pool()->::aapt::pb::StringPool::MergeFrom(from.symbol_pool());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ResourceTable::CopyFrom(const ResourceTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceTable::IsInitialized() const {

  return true;
}

void ResourceTable::Swap(ResourceTable* other) {
  if (other != this) {
    std::swap(string_pool_, other->string_pool_);
    std::swap(source_pool_, other->source_pool_);
    std::swap(symbol_pool_, other->symbol_pool_);
    packages_.Swap(&other->packages_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResourceTable::GetTypeName() const {
  return "aapt.pb.ResourceTable";
}


// ===================================================================

#ifndef _MSC_VER
const int Package::kPackageIdFieldNumber;
const int Package::kPackageNameFieldNumber;
const int Package::kTypesFieldNumber;
#endif  // !_MSC_VER

Package::Package()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Package)
}

void Package::InitAsDefaultInstance() {
}

Package::Package(const Package& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Package)
}

void Package::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  package_id_ = 0u;
  package_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Package::~Package() {
  // @@protoc_insertion_point(destructor:aapt.pb.Package)
  SharedDtor();
}

void Package::SharedDtor() {
  if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Package::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Package& Package::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Package* Package::default_instance_ = NULL;

Package* Package::New() const {
  return new Package;
}

void Package::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    package_id_ = 0u;
    if (has_package_name()) {
      if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        package_name_->clear();
      }
    }
  }
  types_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Package::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Package)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 package_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &package_id_)));
          set_has_package_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_package_name;
        break;
      }

      // optional string package_name = 2;
      case 2: {
        if (tag == 18) {
         parse_package_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_types;
        break;
      }

      // repeated .aapt.pb.Type types = 3;
      case 3: {
        if (tag == 26) {
         parse_types:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_types()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_types;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Package)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Package)
  return false;
#undef DO_
}

void Package::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Package)
  // optional uint32 package_id = 1;
  if (has_package_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->package_id(), output);
  }

  // optional string package_name = 2;
  if (has_package_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->package_name(), output);
  }

  // repeated .aapt.pb.Type types = 3;
  for (int i = 0; i < this->types_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->types(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Package)
}

int Package::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 package_id = 1;
    if (has_package_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->package_id());
    }

    // optional string package_name = 2;
    if (has_package_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_name());
    }

  }
  // repeated .aapt.pb.Type types = 3;
  total_size += 1 * this->types_size();
  for (int i = 0; i < this->types_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->types(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Package::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Package*>(&from));
}

void Package::MergeFrom(const Package& from) {
  GOOGLE_CHECK_NE(&from, this);
  types_.MergeFrom(from.types_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_id()) {
      set_package_id(from.package_id());
    }
    if (from.has_package_name()) {
      set_package_name(from.package_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Package::CopyFrom(const Package& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Package::IsInitialized() const {

  return true;
}

void Package::Swap(Package* other) {
  if (other != this) {
    std::swap(package_id_, other->package_id_);
    std::swap(package_name_, other->package_name_);
    types_.Swap(&other->types_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Package::GetTypeName() const {
  return "aapt.pb.Package";
}


// ===================================================================

#ifndef _MSC_VER
const int Type::kIdFieldNumber;
const int Type::kNameFieldNumber;
const int Type::kEntriesFieldNumber;
#endif  // !_MSC_VER

Type::Type()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Type)
}

void Type::InitAsDefaultInstance() {
}

Type::Type(const Type& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Type)
}

void Type::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Type::~Type() {
  // @@protoc_insertion_point(destructor:aapt.pb.Type)
  SharedDtor();
}

void Type::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Type::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Type& Type::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Type* Type::default_instance_ = NULL;

Type* Type::New() const {
  return new Type;
}

void Type::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Type::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Type)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entries;
        break;
      }

      // repeated .aapt.pb.Entry entries = 3;
      case 3: {
        if (tag == 26) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Type)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Type)
  return false;
#undef DO_
}

void Type::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Type)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // repeated .aapt.pb.Entry entries = 3;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->entries(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Type)
}

int Type::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .aapt.pb.Entry entries = 3;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Type::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Type*>(&from));
}

void Type::MergeFrom(const Type& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Type::CopyFrom(const Type& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Type::IsInitialized() const {

  return true;
}

void Type::Swap(Type* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Type::GetTypeName() const {
  return "aapt.pb.Type";
}


// ===================================================================

bool SymbolStatus_Visibility_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SymbolStatus_Visibility SymbolStatus::Unknown;
const SymbolStatus_Visibility SymbolStatus::Private;
const SymbolStatus_Visibility SymbolStatus::Public;
const SymbolStatus_Visibility SymbolStatus::Visibility_MIN;
const SymbolStatus_Visibility SymbolStatus::Visibility_MAX;
const int SymbolStatus::Visibility_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SymbolStatus::kVisibilityFieldNumber;
const int SymbolStatus::kSourceFieldNumber;
const int SymbolStatus::kCommentFieldNumber;
#endif  // !_MSC_VER

SymbolStatus::SymbolStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.SymbolStatus)
}

void SymbolStatus::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
}

SymbolStatus::SymbolStatus(const SymbolStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.SymbolStatus)
}

void SymbolStatus::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  visibility_ = 0;
  source_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SymbolStatus::~SymbolStatus() {
  // @@protoc_insertion_point(destructor:aapt.pb.SymbolStatus)
  SharedDtor();
}

void SymbolStatus::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
  }
}

void SymbolStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SymbolStatus& SymbolStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

SymbolStatus* SymbolStatus::default_instance_ = NULL;

SymbolStatus* SymbolStatus::New() const {
  return new SymbolStatus;
}

void SymbolStatus::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    visibility_ = 0;
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        comment_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SymbolStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.SymbolStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aapt::pb::SymbolStatus_Visibility_IsValid(value)) {
            set_visibility(static_cast< ::aapt::pb::SymbolStatus_Visibility >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_source;
        break;
      }

      // optional .aapt.pb.Source source = 2;
      case 2: {
        if (tag == 18) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_comment;
        break;
      }

      // optional string comment = 3;
      case 3: {
        if (tag == 26) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.SymbolStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.SymbolStatus)
  return false;
#undef DO_
}

void SymbolStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.SymbolStatus)
  // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->visibility(), output);
  }

  // optional .aapt.pb.Source source = 2;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->source(), output);
  }

  // optional string comment = 3;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->comment(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.SymbolStatus)
}

int SymbolStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
    if (has_visibility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visibility());
    }

    // optional .aapt.pb.Source source = 2;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string comment = 3;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SymbolStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SymbolStatus*>(&from));
}

void SymbolStatus::MergeFrom(const SymbolStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SymbolStatus::CopyFrom(const SymbolStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymbolStatus::IsInitialized() const {

  return true;
}

void SymbolStatus::Swap(SymbolStatus* other) {
  if (other != this) {
    std::swap(visibility_, other->visibility_);
    std::swap(source_, other->source_);
    std::swap(comment_, other->comment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SymbolStatus::GetTypeName() const {
  return "aapt.pb.SymbolStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int Entry::kIdFieldNumber;
const int Entry::kNameFieldNumber;
const int Entry::kSymbolStatusFieldNumber;
const int Entry::kConfigValuesFieldNumber;
#endif  // !_MSC_VER

Entry::Entry()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Entry)
}

void Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  symbol_status_ = const_cast< ::aapt::pb::SymbolStatus*>(
      ::aapt::pb::SymbolStatus::internal_default_instance());
#else
  symbol_status_ = const_cast< ::aapt::pb::SymbolStatus*>(&::aapt::pb::SymbolStatus::default_instance());
#endif
}

Entry::Entry(const Entry& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Entry)
}

void Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  symbol_status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entry::~Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Entry)
  SharedDtor();
}

void Entry::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete symbol_status_;
  }
}

void Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Entry& Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Entry* Entry::default_instance_ = NULL;

Entry* Entry::New() const {
  return new Entry;
}

void Entry::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_symbol_status()) {
      if (symbol_status_ != NULL) symbol_status_->::aapt::pb::SymbolStatus::Clear();
    }
  }
  config_values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_symbol_status;
        break;
      }

      // optional .aapt.pb.SymbolStatus symbol_status = 3;
      case 3: {
        if (tag == 26) {
         parse_symbol_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_symbol_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_config_values;
        break;
      }

      // repeated .aapt.pb.ConfigValue config_values = 4;
      case 4: {
        if (tag == 34) {
         parse_config_values:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_config_values()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_config_values;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Entry)
  return false;
#undef DO_
}

void Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Entry)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional .aapt.pb.SymbolStatus symbol_status = 3;
  if (has_symbol_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->symbol_status(), output);
  }

  // repeated .aapt.pb.ConfigValue config_values = 4;
  for (int i = 0; i < this->config_values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->config_values(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Entry)
}

int Entry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .aapt.pb.SymbolStatus symbol_status = 3;
    if (has_symbol_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->symbol_status());
    }

  }
  // repeated .aapt.pb.ConfigValue config_values = 4;
  total_size += 1 * this->config_values_size();
  for (int i = 0; i < this->config_values_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->config_values(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Entry*>(&from));
}

void Entry::MergeFrom(const Entry& from) {
  GOOGLE_CHECK_NE(&from, this);
  config_values_.MergeFrom(from.config_values_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_symbol_status()) {
      mutable_symbol_status()->::aapt::pb::SymbolStatus::MergeFrom(from.symbol_status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Entry::CopyFrom(const Entry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entry::IsInitialized() const {

  return true;
}

void Entry::Swap(Entry* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(symbol_status_, other->symbol_status_);
    config_values_.Swap(&other->config_values_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Entry::GetTypeName() const {
  return "aapt.pb.Entry";
}


// ===================================================================

#ifndef _MSC_VER
const int ConfigValue::kConfigFieldNumber;
const int ConfigValue::kValueFieldNumber;
#endif  // !_MSC_VER

ConfigValue::ConfigValue()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.ConfigValue)
}

void ConfigValue::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::aapt::pb::ConfigDescription*>(
      ::aapt::pb::ConfigDescription::internal_default_instance());
#else
  config_ = const_cast< ::aapt::pb::ConfigDescription*>(&::aapt::pb::ConfigDescription::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  value_ = const_cast< ::aapt::pb::Value*>(
      ::aapt::pb::Value::internal_default_instance());
#else
  value_ = const_cast< ::aapt::pb::Value*>(&::aapt::pb::Value::default_instance());
#endif
}

ConfigValue::ConfigValue(const ConfigValue& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.ConfigValue)
}

void ConfigValue::SharedCtor() {
  _cached_size_ = 0;
  config_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigValue::~ConfigValue() {
  // @@protoc_insertion_point(destructor:aapt.pb.ConfigValue)
  SharedDtor();
}

void ConfigValue::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete config_;
    delete value_;
  }
}

void ConfigValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigValue& ConfigValue::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

ConfigValue* ConfigValue::default_instance_ = NULL;

ConfigValue* ConfigValue::New() const {
  return new ConfigValue;
}

void ConfigValue::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_config()) {
      if (config_ != NULL) config_->::aapt::pb::ConfigDescription::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::aapt::pb::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConfigValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.ConfigValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.ConfigDescription config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .aapt.pb.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.ConfigValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.ConfigValue)
  return false;
#undef DO_
}

void ConfigValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.ConfigValue)
  // optional .aapt.pb.ConfigDescription config = 1;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->config(), output);
  }

  // optional .aapt.pb.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.ConfigValue)
}

int ConfigValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.ConfigDescription config = 1;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->config());
    }

    // optional .aapt.pb.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigValue*>(&from));
}

void ConfigValue::MergeFrom(const ConfigValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_config()) {
      mutable_config()->::aapt::pb::ConfigDescription::MergeFrom(from.config());
    }
    if (from.has_value()) {
      mutable_value()->::aapt::pb::Value::MergeFrom(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConfigValue::CopyFrom(const ConfigValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigValue::IsInitialized() const {

  return true;
}

void ConfigValue::Swap(ConfigValue* other) {
  if (other != this) {
    std::swap(config_, other->config_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigValue::GetTypeName() const {
  return "aapt.pb.ConfigValue";
}


// ===================================================================

#ifndef _MSC_VER
const int Source::kPathIdxFieldNumber;
const int Source::kLineNoFieldNumber;
const int Source::kColNoFieldNumber;
#endif  // !_MSC_VER

Source::Source()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Source)
}

void Source::InitAsDefaultInstance() {
}

Source::Source(const Source& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Source)
}

void Source::SharedCtor() {
  _cached_size_ = 0;
  path_idx_ = 0u;
  line_no_ = 0u;
  col_no_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Source::~Source() {
  // @@protoc_insertion_point(destructor:aapt.pb.Source)
  SharedDtor();
}

void Source::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Source::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Source& Source::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Source* Source::default_instance_ = NULL;

Source* Source::New() const {
  return new Source;
}

void Source::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Source*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&(first), 0, n);                              \
  } while (0)

  ZR_(path_idx_, col_no_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Source::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Source)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 path_idx = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &path_idx_)));
          set_has_path_idx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_line_no;
        break;
      }

      // optional uint32 line_no = 2;
      case 2: {
        if (tag == 16) {
         parse_line_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &line_no_)));
          set_has_line_no();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_col_no;
        break;
      }

      // optional uint32 col_no = 3;
      case 3: {
        if (tag == 24) {
         parse_col_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &col_no_)));
          set_has_col_no();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Source)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Source)
  return false;
#undef DO_
}

void Source::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Source)
  // optional uint32 path_idx = 1;
  if (has_path_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->path_idx(), output);
  }

  // optional uint32 line_no = 2;
  if (has_line_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->line_no(), output);
  }

  // optional uint32 col_no = 3;
  if (has_col_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->col_no(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Source)
}

int Source::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 path_idx = 1;
    if (has_path_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->path_idx());
    }

    // optional uint32 line_no = 2;
    if (has_line_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->line_no());
    }

    // optional uint32 col_no = 3;
    if (has_col_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->col_no());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Source::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Source*>(&from));
}

void Source::MergeFrom(const Source& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path_idx()) {
      set_path_idx(from.path_idx());
    }
    if (from.has_line_no()) {
      set_line_no(from.line_no());
    }
    if (from.has_col_no()) {
      set_col_no(from.col_no());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Source::CopyFrom(const Source& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Source::IsInitialized() const {

  return true;
}

void Source::Swap(Source* other) {
  if (other != this) {
    std::swap(path_idx_, other->path_idx_);
    std::swap(line_no_, other->line_no_);
    std::swap(col_no_, other->col_no_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Source::GetTypeName() const {
  return "aapt.pb.Source";
}


// ===================================================================

bool Reference_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Reference_Type Reference::Ref;
const Reference_Type Reference::Attr;
const Reference_Type Reference::Type_MIN;
const Reference_Type Reference::Type_MAX;
const int Reference::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Reference::kTypeFieldNumber;
const int Reference::kIdFieldNumber;
const int Reference::kSymbolIdxFieldNumber;
const int Reference::kPrivateFieldNumber;
#endif  // !_MSC_VER

Reference::Reference()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Reference)
}

void Reference::InitAsDefaultInstance() {
}

Reference::Reference(const Reference& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Reference)
}

void Reference::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  id_ = 0u;
  symbol_idx_ = 0u;
  private__ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reference::~Reference() {
  // @@protoc_insertion_point(destructor:aapt.pb.Reference)
  SharedDtor();
}

void Reference::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Reference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Reference& Reference::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Reference* Reference::default_instance_ = NULL;

Reference* Reference::New() const {
  return new Reference;
}

void Reference::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Reference*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&(first), 0, n);                              \
  } while (0)

  ZR_(type_, private__);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Reference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Reference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Reference.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aapt::pb::Reference_Type_IsValid(value)) {
            set_type(static_cast< ::aapt::pb::Reference_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional uint32 id = 2;
      case 2: {
        if (tag == 16) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_symbol_idx;
        break;
      }

      // optional uint32 symbol_idx = 3;
      case 3: {
        if (tag == 24) {
         parse_symbol_idx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &symbol_idx_)));
          set_has_symbol_idx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_private;
        break;
      }

      // optional bool private = 4;
      case 4: {
        if (tag == 32) {
         parse_private:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &private__)));
          set_has_private_();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Reference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Reference)
  return false;
#undef DO_
}

void Reference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Reference)
  // optional .aapt.pb.Reference.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // optional uint32 symbol_idx = 3;
  if (has_symbol_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->symbol_idx(), output);
  }

  // optional bool private = 4;
  if (has_private_()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->private_(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Reference)
}

int Reference::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Reference.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional uint32 symbol_idx = 3;
    if (has_symbol_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->symbol_idx());
    }

    // optional bool private = 4;
    if (has_private_()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reference::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Reference*>(&from));
}

void Reference::MergeFrom(const Reference& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_symbol_idx()) {
      set_symbol_idx(from.symbol_idx());
    }
    if (from.has_private_()) {
      set_private_(from.private_());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Reference::CopyFrom(const Reference& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reference::IsInitialized() const {

  return true;
}

void Reference::Swap(Reference* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(id_, other->id_);
    std::swap(symbol_idx_, other->symbol_idx_);
    std::swap(private__, other->private__);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Reference::GetTypeName() const {
  return "aapt.pb.Reference";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Id::Id()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Id)
}

void Id::InitAsDefaultInstance() {
}

Id::Id(const Id& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Id)
}

void Id::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Id::~Id() {
  // @@protoc_insertion_point(destructor:aapt.pb.Id)
  SharedDtor();
}

void Id::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Id::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Id& Id::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Id* Id::default_instance_ = NULL;

Id* Id::New() const {
  return new Id;
}

void Id::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Id::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Id)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Id)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Id)
  return false;
#undef DO_
}

void Id::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Id)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Id)
}

int Id::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Id::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Id*>(&from));
}

void Id::MergeFrom(const Id& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Id::CopyFrom(const Id& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Id::IsInitialized() const {

  return true;
}

void Id::Swap(Id* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Id::GetTypeName() const {
  return "aapt.pb.Id";
}


// ===================================================================

#ifndef _MSC_VER
const int String::kIdxFieldNumber;
#endif  // !_MSC_VER

String::String()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.String)
}

void String::InitAsDefaultInstance() {
}

String::String(const String& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.String)
}

void String::SharedCtor() {
  _cached_size_ = 0;
  idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

String::~String() {
  // @@protoc_insertion_point(destructor:aapt.pb.String)
  SharedDtor();
}

void String::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void String::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const String& String::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

String* String::default_instance_ = NULL;

String* String::New() const {
  return new String;
}

void String::Clear() {
  idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool String::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.String)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 idx = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &idx_)));
          set_has_idx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.String)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.String)
  return false;
#undef DO_
}

void String::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.String)
  // optional uint32 idx = 1;
  if (has_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->idx(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.String)
}

int String::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 idx = 1;
    if (has_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->idx());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void String::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const String*>(&from));
}

void String::MergeFrom(const String& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_idx()) {
      set_idx(from.idx());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void String::CopyFrom(const String& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool String::IsInitialized() const {

  return true;
}

void String::Swap(String* other) {
  if (other != this) {
    std::swap(idx_, other->idx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string String::GetTypeName() const {
  return "aapt.pb.String";
}


// ===================================================================

#ifndef _MSC_VER
const int RawString::kIdxFieldNumber;
#endif  // !_MSC_VER

RawString::RawString()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.RawString)
}

void RawString::InitAsDefaultInstance() {
}

RawString::RawString(const RawString& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.RawString)
}

void RawString::SharedCtor() {
  _cached_size_ = 0;
  idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawString::~RawString() {
  // @@protoc_insertion_point(destructor:aapt.pb.RawString)
  SharedDtor();
}

void RawString::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RawString::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RawString& RawString::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

RawString* RawString::default_instance_ = NULL;

RawString* RawString::New() const {
  return new RawString;
}

void RawString::Clear() {
  idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RawString::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.RawString)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 idx = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &idx_)));
          set_has_idx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.RawString)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.RawString)
  return false;
#undef DO_
}

void RawString::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.RawString)
  // optional uint32 idx = 1;
  if (has_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->idx(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.RawString)
}

int RawString::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 idx = 1;
    if (has_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->idx());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawString::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RawString*>(&from));
}

void RawString::MergeFrom(const RawString& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_idx()) {
      set_idx(from.idx());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RawString::CopyFrom(const RawString& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawString::IsInitialized() const {

  return true;
}

void RawString::Swap(RawString* other) {
  if (other != this) {
    std::swap(idx_, other->idx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RawString::GetTypeName() const {
  return "aapt.pb.RawString";
}


// ===================================================================

#ifndef _MSC_VER
const int FileReference::kPathIdxFieldNumber;
#endif  // !_MSC_VER

FileReference::FileReference()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.FileReference)
}

void FileReference::InitAsDefaultInstance() {
}

FileReference::FileReference(const FileReference& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.FileReference)
}

void FileReference::SharedCtor() {
  _cached_size_ = 0;
  path_idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileReference::~FileReference() {
  // @@protoc_insertion_point(destructor:aapt.pb.FileReference)
  SharedDtor();
}

void FileReference::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileReference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileReference& FileReference::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

FileReference* FileReference::default_instance_ = NULL;

FileReference* FileReference::New() const {
  return new FileReference;
}

void FileReference::Clear() {
  path_idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool FileReference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.FileReference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 path_idx = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &path_idx_)));
          set_has_path_idx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.FileReference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.FileReference)
  return false;
#undef DO_
}

void FileReference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.FileReference)
  // optional uint32 path_idx = 1;
  if (has_path_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->path_idx(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.FileReference)
}

int FileReference::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 path_idx = 1;
    if (has_path_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->path_idx());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileReference::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileReference*>(&from));
}

void FileReference::MergeFrom(const FileReference& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path_idx()) {
      set_path_idx(from.path_idx());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void FileReference::CopyFrom(const FileReference& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileReference::IsInitialized() const {

  return true;
}

void FileReference::Swap(FileReference* other) {
  if (other != this) {
    std::swap(path_idx_, other->path_idx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileReference::GetTypeName() const {
  return "aapt.pb.FileReference";
}


// ===================================================================

#ifndef _MSC_VER
const int Primitive::kTypeFieldNumber;
const int Primitive::kDataFieldNumber;
#endif  // !_MSC_VER

Primitive::Primitive()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Primitive)
}

void Primitive::InitAsDefaultInstance() {
}

Primitive::Primitive(const Primitive& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Primitive)
}

void Primitive::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  data_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Primitive::~Primitive() {
  // @@protoc_insertion_point(destructor:aapt.pb.Primitive)
  SharedDtor();
}

void Primitive::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Primitive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Primitive& Primitive::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Primitive* Primitive::default_instance_ = NULL;

Primitive* Primitive::New() const {
  return new Primitive;
}

void Primitive::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Primitive*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&(first), 0, n);                              \
  } while (0)

  ZR_(type_, data_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Primitive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Primitive)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_data;
        break;
      }

      // optional uint32 data = 2;
      case 2: {
        if (tag == 16) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_)));
          set_has_data();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Primitive)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Primitive)
  return false;
#undef DO_
}

void Primitive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Primitive)
  // optional uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // optional uint32 data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Primitive)
}

int Primitive::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Primitive::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Primitive*>(&from));
}

void Primitive::MergeFrom(const Primitive& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Primitive::CopyFrom(const Primitive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Primitive::IsInitialized() const {

  return true;
}

void Primitive::Swap(Primitive* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Primitive::GetTypeName() const {
  return "aapt.pb.Primitive";
}


// ===================================================================

#ifndef _MSC_VER
const int Attribute_Symbol::kSourceFieldNumber;
const int Attribute_Symbol::kCommentFieldNumber;
const int Attribute_Symbol::kNameFieldNumber;
const int Attribute_Symbol::kValueFieldNumber;
#endif  // !_MSC_VER

Attribute_Symbol::Attribute_Symbol()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Attribute.Symbol)
}

void Attribute_Symbol::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  name_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  name_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
}

Attribute_Symbol::Attribute_Symbol(const Attribute_Symbol& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Attribute.Symbol)
}

void Attribute_Symbol::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_ = NULL;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attribute_Symbol::~Attribute_Symbol() {
  // @@protoc_insertion_point(destructor:aapt.pb.Attribute.Symbol)
  SharedDtor();
}

void Attribute_Symbol::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete name_;
  }
}

void Attribute_Symbol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Attribute_Symbol& Attribute_Symbol::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Attribute_Symbol* Attribute_Symbol::default_instance_ = NULL;

Attribute_Symbol* Attribute_Symbol::New() const {
  return new Attribute_Symbol;
}

void Attribute_Symbol::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        comment_->clear();
      }
    }
    if (has_name()) {
      if (name_ != NULL) name_->::aapt::pb::Reference::Clear();
    }
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Attribute_Symbol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Attribute.Symbol)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional .aapt.pb.Reference name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_value;
        break;
      }

      // optional uint32 value = 4;
      case 4: {
        if (tag == 32) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Attribute.Symbol)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Attribute.Symbol)
  return false;
#undef DO_
}

void Attribute_Symbol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Attribute.Symbol)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Reference name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->name(), output);
  }

  // optional uint32 value = 4;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Attribute.Symbol)
}

int Attribute_Symbol::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Reference name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name());
    }

    // optional uint32 value = 4;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attribute_Symbol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Attribute_Symbol*>(&from));
}

void Attribute_Symbol::MergeFrom(const Attribute_Symbol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_name()) {
      mutable_name()->::aapt::pb::Reference::MergeFrom(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Attribute_Symbol::CopyFrom(const Attribute_Symbol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribute_Symbol::IsInitialized() const {

  return true;
}

void Attribute_Symbol::Swap(Attribute_Symbol* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(comment_, other->comment_);
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Attribute_Symbol::GetTypeName() const {
  return "aapt.pb.Attribute.Symbol";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Attribute::kFormatFlagsFieldNumber;
const int Attribute::kMinIntFieldNumber;
const int Attribute::kMaxIntFieldNumber;
const int Attribute::kSymbolsFieldNumber;
#endif  // !_MSC_VER

Attribute::Attribute()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Attribute)
}

void Attribute::InitAsDefaultInstance() {
}

Attribute::Attribute(const Attribute& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Attribute)
}

void Attribute::SharedCtor() {
  _cached_size_ = 0;
  format_flags_ = 0u;
  min_int_ = 0;
  max_int_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attribute::~Attribute() {
  // @@protoc_insertion_point(destructor:aapt.pb.Attribute)
  SharedDtor();
}

void Attribute::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Attribute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Attribute& Attribute::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Attribute* Attribute::default_instance_ = NULL;

Attribute* Attribute::New() const {
  return new Attribute;
}

void Attribute::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Attribute*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&(first), 0, n);                              \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(format_flags_, min_int_);
    max_int_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  symbols_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Attribute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Attribute)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 format_flags = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &format_flags_)));
          set_has_format_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_min_int;
        break;
      }

      // optional int32 min_int = 2;
      case 2: {
        if (tag == 16) {
         parse_min_int:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_int_)));
          set_has_min_int();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_max_int;
        break;
      }

      // optional int32 max_int = 3;
      case 3: {
        if (tag == 24) {
         parse_max_int:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_int_)));
          set_has_max_int();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_symbols;
        break;
      }

      // repeated .aapt.pb.Attribute.Symbol symbols = 4;
      case 4: {
        if (tag == 34) {
         parse_symbols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_symbols()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_symbols;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Attribute)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Attribute)
  return false;
#undef DO_
}

void Attribute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Attribute)
  // optional uint32 format_flags = 1;
  if (has_format_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->format_flags(), output);
  }

  // optional int32 min_int = 2;
  if (has_min_int()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->min_int(), output);
  }

  // optional int32 max_int = 3;
  if (has_max_int()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->max_int(), output);
  }

  // repeated .aapt.pb.Attribute.Symbol symbols = 4;
  for (int i = 0; i < this->symbols_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->symbols(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Attribute)
}

int Attribute::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 format_flags = 1;
    if (has_format_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->format_flags());
    }

    // optional int32 min_int = 2;
    if (has_min_int()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min_int());
    }

    // optional int32 max_int = 3;
    if (has_max_int()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_int());
    }

  }
  // repeated .aapt.pb.Attribute.Symbol symbols = 4;
  total_size += 1 * this->symbols_size();
  for (int i = 0; i < this->symbols_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->symbols(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attribute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Attribute*>(&from));
}

void Attribute::MergeFrom(const Attribute& from) {
  GOOGLE_CHECK_NE(&from, this);
  symbols_.MergeFrom(from.symbols_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_format_flags()) {
      set_format_flags(from.format_flags());
    }
    if (from.has_min_int()) {
      set_min_int(from.min_int());
    }
    if (from.has_max_int()) {
      set_max_int(from.max_int());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Attribute::CopyFrom(const Attribute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribute::IsInitialized() const {

  return true;
}

void Attribute::Swap(Attribute* other) {
  if (other != this) {
    std::swap(format_flags_, other->format_flags_);
    std::swap(min_int_, other->min_int_);
    std::swap(max_int_, other->max_int_);
    symbols_.Swap(&other->symbols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Attribute::GetTypeName() const {
  return "aapt.pb.Attribute";
}


// ===================================================================

#ifndef _MSC_VER
const int Style_Entry::kSourceFieldNumber;
const int Style_Entry::kCommentFieldNumber;
const int Style_Entry::kKeyFieldNumber;
const int Style_Entry::kItemFieldNumber;
#endif  // !_MSC_VER

Style_Entry::Style_Entry()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Style.Entry)
}

void Style_Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  key_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  key_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
}

Style_Entry::Style_Entry(const Style_Entry& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Style.Entry)
}

void Style_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_ = NULL;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Style_Entry::~Style_Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Style.Entry)
  SharedDtor();
}

void Style_Entry::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete key_;
    delete item_;
  }
}

void Style_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Style_Entry& Style_Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Style_Entry* Style_Entry::default_instance_ = NULL;

Style_Entry* Style_Entry::New() const {
  return new Style_Entry;
}

void Style_Entry::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        comment_->clear();
      }
    }
    if (has_key()) {
      if (key_ != NULL) key_->::aapt::pb::Reference::Clear();
    }
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Style_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Style.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_key;
        break;
      }

      // optional .aapt.pb.Reference key = 3;
      case 3: {
        if (tag == 26) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 4;
      case 4: {
        if (tag == 34) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Style.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Style.Entry)
  return false;
#undef DO_
}

void Style_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Style.Entry)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Reference key = 3;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->key(), output);
  }

  // optional .aapt.pb.Item item = 4;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->item(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Style.Entry)
}

int Style_Entry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Reference key = 3;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->key());
    }

    // optional .aapt.pb.Item item = 4;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Style_Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Style_Entry*>(&from));
}

void Style_Entry::MergeFrom(const Style_Entry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_key()) {
      mutable_key()->::aapt::pb::Reference::MergeFrom(from.key());
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Style_Entry::CopyFrom(const Style_Entry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Style_Entry::IsInitialized() const {

  return true;
}

void Style_Entry::Swap(Style_Entry* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(comment_, other->comment_);
    std::swap(key_, other->key_);
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Style_Entry::GetTypeName() const {
  return "aapt.pb.Style.Entry";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Style::kParentFieldNumber;
const int Style::kParentSourceFieldNumber;
const int Style::kEntriesFieldNumber;
#endif  // !_MSC_VER

Style::Style()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Style)
}

void Style::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  parent_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  parent_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  parent_source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  parent_source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
}

Style::Style(const Style& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Style)
}

void Style::SharedCtor() {
  _cached_size_ = 0;
  parent_ = NULL;
  parent_source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Style::~Style() {
  // @@protoc_insertion_point(destructor:aapt.pb.Style)
  SharedDtor();
}

void Style::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete parent_;
    delete parent_source_;
  }
}

void Style::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Style& Style::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Style* Style::default_instance_ = NULL;

Style* Style::New() const {
  return new Style;
}

void Style::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_parent()) {
      if (parent_ != NULL) parent_->::aapt::pb::Reference::Clear();
    }
    if (has_parent_source()) {
      if (parent_source_ != NULL) parent_source_->::aapt::pb::Source::Clear();
    }
  }
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Style::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Style)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Reference parent = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parent_source;
        break;
      }

      // optional .aapt.pb.Source parent_source = 2;
      case 2: {
        if (tag == 18) {
         parse_parent_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entries;
        break;
      }

      // repeated .aapt.pb.Style.Entry entries = 3;
      case 3: {
        if (tag == 26) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Style)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Style)
  return false;
#undef DO_
}

void Style::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Style)
  // optional .aapt.pb.Reference parent = 1;
  if (has_parent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->parent(), output);
  }

  // optional .aapt.pb.Source parent_source = 2;
  if (has_parent_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->parent_source(), output);
  }

  // repeated .aapt.pb.Style.Entry entries = 3;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->entries(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Style)
}

int Style::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Reference parent = 1;
    if (has_parent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parent());
    }

    // optional .aapt.pb.Source parent_source = 2;
    if (has_parent_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parent_source());
    }

  }
  // repeated .aapt.pb.Style.Entry entries = 3;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Style::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Style*>(&from));
}

void Style::MergeFrom(const Style& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_parent()) {
      mutable_parent()->::aapt::pb::Reference::MergeFrom(from.parent());
    }
    if (from.has_parent_source()) {
      mutable_parent_source()->::aapt::pb::Source::MergeFrom(from.parent_source());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Style::CopyFrom(const Style& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Style::IsInitialized() const {

  return true;
}

void Style::Swap(Style* other) {
  if (other != this) {
    std::swap(parent_, other->parent_);
    std::swap(parent_source_, other->parent_source_);
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Style::GetTypeName() const {
  return "aapt.pb.Style";
}


// ===================================================================

#ifndef _MSC_VER
const int Styleable_Entry::kSourceFieldNumber;
const int Styleable_Entry::kCommentFieldNumber;
const int Styleable_Entry::kAttrFieldNumber;
#endif  // !_MSC_VER

Styleable_Entry::Styleable_Entry()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Styleable.Entry)
}

void Styleable_Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attr_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  attr_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
}

Styleable_Entry::Styleable_Entry(const Styleable_Entry& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Styleable.Entry)
}

void Styleable_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attr_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Styleable_Entry::~Styleable_Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Styleable.Entry)
  SharedDtor();
}

void Styleable_Entry::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete attr_;
  }
}

void Styleable_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Styleable_Entry& Styleable_Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Styleable_Entry* Styleable_Entry::default_instance_ = NULL;

Styleable_Entry* Styleable_Entry::New() const {
  return new Styleable_Entry;
}

void Styleable_Entry::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        comment_->clear();
      }
    }
    if (has_attr()) {
      if (attr_ != NULL) attr_->::aapt::pb::Reference::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Styleable_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Styleable.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_attr;
        break;
      }

      // optional .aapt.pb.Reference attr = 3;
      case 3: {
        if (tag == 26) {
         parse_attr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Styleable.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Styleable.Entry)
  return false;
#undef DO_
}

void Styleable_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Styleable.Entry)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Reference attr = 3;
  if (has_attr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->attr(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Styleable.Entry)
}

int Styleable_Entry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Reference attr = 3;
    if (has_attr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attr());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Styleable_Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Styleable_Entry*>(&from));
}

void Styleable_Entry::MergeFrom(const Styleable_Entry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_attr()) {
      mutable_attr()->::aapt::pb::Reference::MergeFrom(from.attr());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Styleable_Entry::CopyFrom(const Styleable_Entry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Styleable_Entry::IsInitialized() const {

  return true;
}

void Styleable_Entry::Swap(Styleable_Entry* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(comment_, other->comment_);
    std::swap(attr_, other->attr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Styleable_Entry::GetTypeName() const {
  return "aapt.pb.Styleable.Entry";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Styleable::kEntriesFieldNumber;
#endif  // !_MSC_VER

Styleable::Styleable()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Styleable)
}

void Styleable::InitAsDefaultInstance() {
}

Styleable::Styleable(const Styleable& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Styleable)
}

void Styleable::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Styleable::~Styleable() {
  // @@protoc_insertion_point(destructor:aapt.pb.Styleable)
  SharedDtor();
}

void Styleable::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Styleable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Styleable& Styleable::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Styleable* Styleable::default_instance_ = NULL;

Styleable* Styleable::New() const {
  return new Styleable;
}

void Styleable::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Styleable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Styleable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aapt.pb.Styleable.Entry entries = 1;
      case 1: {
        if (tag == 10) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Styleable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Styleable)
  return false;
#undef DO_
}

void Styleable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Styleable)
  // repeated .aapt.pb.Styleable.Entry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->entries(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Styleable)
}

int Styleable::ByteSize() const {
  int total_size = 0;

  // repeated .aapt.pb.Styleable.Entry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Styleable::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Styleable*>(&from));
}

void Styleable::MergeFrom(const Styleable& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Styleable::CopyFrom(const Styleable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Styleable::IsInitialized() const {

  return true;
}

void Styleable::Swap(Styleable* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Styleable::GetTypeName() const {
  return "aapt.pb.Styleable";
}


// ===================================================================

#ifndef _MSC_VER
const int Array_Entry::kSourceFieldNumber;
const int Array_Entry::kCommentFieldNumber;
const int Array_Entry::kItemFieldNumber;
#endif  // !_MSC_VER

Array_Entry::Array_Entry()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Array.Entry)
}

void Array_Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
}

Array_Entry::Array_Entry(const Array_Entry& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Array.Entry)
}

void Array_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Array_Entry::~Array_Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Array.Entry)
  SharedDtor();
}

void Array_Entry::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete item_;
  }
}

void Array_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Array_Entry& Array_Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Array_Entry* Array_Entry::default_instance_ = NULL;

Array_Entry* Array_Entry::New() const {
  return new Array_Entry;
}

void Array_Entry::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        comment_->clear();
      }
    }
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Array_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Array.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 3;
      case 3: {
        if (tag == 26) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Array.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Array.Entry)
  return false;
#undef DO_
}

void Array_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Array.Entry)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Item item = 3;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->item(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Array.Entry)
}

int Array_Entry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Item item = 3;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Array_Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Array_Entry*>(&from));
}

void Array_Entry::MergeFrom(const Array_Entry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Array_Entry::CopyFrom(const Array_Entry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Array_Entry::IsInitialized() const {

  return true;
}

void Array_Entry::Swap(Array_Entry* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(comment_, other->comment_);
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Array_Entry::GetTypeName() const {
  return "aapt.pb.Array.Entry";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Array::kEntriesFieldNumber;
#endif  // !_MSC_VER

Array::Array()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Array)
}

void Array::InitAsDefaultInstance() {
}

Array::Array(const Array& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Array)
}

void Array::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Array::~Array() {
  // @@protoc_insertion_point(destructor:aapt.pb.Array)
  SharedDtor();
}

void Array::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Array::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Array& Array::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Array* Array::default_instance_ = NULL;

Array* Array::New() const {
  return new Array;
}

void Array::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Array::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Array)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aapt.pb.Array.Entry entries = 1;
      case 1: {
        if (tag == 10) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Array)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Array)
  return false;
#undef DO_
}

void Array::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Array)
  // repeated .aapt.pb.Array.Entry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->entries(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Array)
}

int Array::ByteSize() const {
  int total_size = 0;

  // repeated .aapt.pb.Array.Entry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Array::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Array*>(&from));
}

void Array::MergeFrom(const Array& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Array::CopyFrom(const Array& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Array::IsInitialized() const {

  return true;
}

void Array::Swap(Array* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Array::GetTypeName() const {
  return "aapt.pb.Array";
}


// ===================================================================

bool Plural_Arity_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Plural_Arity Plural::Zero;
const Plural_Arity Plural::One;
const Plural_Arity Plural::Two;
const Plural_Arity Plural::Few;
const Plural_Arity Plural::Many;
const Plural_Arity Plural::Other;
const Plural_Arity Plural::Arity_MIN;
const Plural_Arity Plural::Arity_MAX;
const int Plural::Arity_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Plural_Entry::kSourceFieldNumber;
const int Plural_Entry::kCommentFieldNumber;
const int Plural_Entry::kArityFieldNumber;
const int Plural_Entry::kItemFieldNumber;
#endif  // !_MSC_VER

Plural_Entry::Plural_Entry()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Plural.Entry)
}

void Plural_Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
}

Plural_Entry::Plural_Entry(const Plural_Entry& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Plural.Entry)
}

void Plural_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  arity_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Plural_Entry::~Plural_Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Plural.Entry)
  SharedDtor();
}

void Plural_Entry::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete item_;
  }
}

void Plural_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Plural_Entry& Plural_Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Plural_Entry* Plural_Entry::default_instance_ = NULL;

Plural_Entry* Plural_Entry::New() const {
  return new Plural_Entry;
}

void Plural_Entry::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        comment_->clear();
      }
    }
    arity_ = 0;
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Plural_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Plural.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_arity;
        break;
      }

      // optional .aapt.pb.Plural.Arity arity = 3;
      case 3: {
        if (tag == 24) {
         parse_arity:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aapt::pb::Plural_Arity_IsValid(value)) {
            set_arity(static_cast< ::aapt::pb::Plural_Arity >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 4;
      case 4: {
        if (tag == 34) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Plural.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Plural.Entry)
  return false;
#undef DO_
}

void Plural_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Plural.Entry)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Plural.Arity arity = 3;
  if (has_arity()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->arity(), output);
  }

  // optional .aapt.pb.Item item = 4;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->item(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Plural.Entry)
}

int Plural_Entry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Plural.Arity arity = 3;
    if (has_arity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->arity());
    }

    // optional .aapt.pb.Item item = 4;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Plural_Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Plural_Entry*>(&from));
}

void Plural_Entry::MergeFrom(const Plural_Entry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_arity()) {
      set_arity(from.arity());
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Plural_Entry::CopyFrom(const Plural_Entry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plural_Entry::IsInitialized() const {

  return true;
}

void Plural_Entry::Swap(Plural_Entry* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(comment_, other->comment_);
    std::swap(arity_, other->arity_);
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Plural_Entry::GetTypeName() const {
  return "aapt.pb.Plural.Entry";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Plural::kEntriesFieldNumber;
#endif  // !_MSC_VER

Plural::Plural()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Plural)
}

void Plural::InitAsDefaultInstance() {
}

Plural::Plural(const Plural& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Plural)
}

void Plural::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Plural::~Plural() {
  // @@protoc_insertion_point(destructor:aapt.pb.Plural)
  SharedDtor();
}

void Plural::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Plural::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Plural& Plural::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Plural* Plural::default_instance_ = NULL;

Plural* Plural::New() const {
  return new Plural;
}

void Plural::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Plural::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Plural)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aapt.pb.Plural.Entry entries = 1;
      case 1: {
        if (tag == 10) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Plural)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Plural)
  return false;
#undef DO_
}

void Plural::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Plural)
  // repeated .aapt.pb.Plural.Entry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->entries(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Plural)
}

int Plural::ByteSize() const {
  int total_size = 0;

  // repeated .aapt.pb.Plural.Entry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Plural::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Plural*>(&from));
}

void Plural::MergeFrom(const Plural& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Plural::CopyFrom(const Plural& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plural::IsInitialized() const {

  return true;
}

void Plural::Swap(Plural* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Plural::GetTypeName() const {
  return "aapt.pb.Plural";
}


// ===================================================================

#ifndef _MSC_VER
const int Item::kRefFieldNumber;
const int Item::kStrFieldNumber;
const int Item::kRawStrFieldNumber;
const int Item::kFileFieldNumber;
const int Item::kIdFieldNumber;
const int Item::kPrimFieldNumber;
#endif  // !_MSC_VER

Item::Item()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Item)
}

void Item::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ref_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  ref_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  str_ = const_cast< ::aapt::pb::String*>(
      ::aapt::pb::String::internal_default_instance());
#else
  str_ = const_cast< ::aapt::pb::String*>(&::aapt::pb::String::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  raw_str_ = const_cast< ::aapt::pb::RawString*>(
      ::aapt::pb::RawString::internal_default_instance());
#else
  raw_str_ = const_cast< ::aapt::pb::RawString*>(&::aapt::pb::RawString::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  file_ = const_cast< ::aapt::pb::FileReference*>(
      ::aapt::pb::FileReference::internal_default_instance());
#else
  file_ = const_cast< ::aapt::pb::FileReference*>(&::aapt::pb::FileReference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aapt::pb::Id*>(
      ::aapt::pb::Id::internal_default_instance());
#else
  id_ = const_cast< ::aapt::pb::Id*>(&::aapt::pb::Id::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  prim_ = const_cast< ::aapt::pb::Primitive*>(
      ::aapt::pb::Primitive::internal_default_instance());
#else
  prim_ = const_cast< ::aapt::pb::Primitive*>(&::aapt::pb::Primitive::default_instance());
#endif
}

Item::Item(const Item& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Item)
}

void Item::SharedCtor() {
  _cached_size_ = 0;
  ref_ = NULL;
  str_ = NULL;
  raw_str_ = NULL;
  file_ = NULL;
  id_ = NULL;
  prim_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Item::~Item() {
  // @@protoc_insertion_point(destructor:aapt.pb.Item)
  SharedDtor();
}

void Item::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ref_;
    delete str_;
    delete raw_str_;
    delete file_;
    delete id_;
    delete prim_;
  }
}

void Item::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Item& Item::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Item* Item::default_instance_ = NULL;

Item* Item::New() const {
  return new Item;
}

void Item::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_ref()) {
      if (ref_ != NULL) ref_->::aapt::pb::Reference::Clear();
    }
    if (has_str()) {
      if (str_ != NULL) str_->::aapt::pb::String::Clear();
    }
    if (has_raw_str()) {
      if (raw_str_ != NULL) raw_str_->::aapt::pb::RawString::Clear();
    }
    if (has_file()) {
      if (file_ != NULL) file_->::aapt::pb::FileReference::Clear();
    }
    if (has_id()) {
      if (id_ != NULL) id_->::aapt::pb::Id::Clear();
    }
    if (has_prim()) {
      if (prim_ != NULL) prim_->::aapt::pb::Primitive::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Item::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Item)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Reference ref = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_str;
        break;
      }

      // optional .aapt.pb.String str = 2;
      case 2: {
        if (tag == 18) {
         parse_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_str()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_raw_str;
        break;
      }

      // optional .aapt.pb.RawString raw_str = 3;
      case 3: {
        if (tag == 26) {
         parse_raw_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_raw_str()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_file;
        break;
      }

      // optional .aapt.pb.FileReference file = 4;
      case 4: {
        if (tag == 34) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_id;
        break;
      }

      // optional .aapt.pb.Id id = 5;
      case 5: {
        if (tag == 42) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_prim;
        break;
      }

      // optional .aapt.pb.Primitive prim = 6;
      case 6: {
        if (tag == 50) {
         parse_prim:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_prim()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Item)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Item)
  return false;
#undef DO_
}

void Item::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Item)
  // optional .aapt.pb.Reference ref = 1;
  if (has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->ref(), output);
  }

  // optional .aapt.pb.String str = 2;
  if (has_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->str(), output);
  }

  // optional .aapt.pb.RawString raw_str = 3;
  if (has_raw_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->raw_str(), output);
  }

  // optional .aapt.pb.FileReference file = 4;
  if (has_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->file(), output);
  }

  // optional .aapt.pb.Id id = 5;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->id(), output);
  }

  // optional .aapt.pb.Primitive prim = 6;
  if (has_prim()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->prim(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Item)
}

int Item::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Reference ref = 1;
    if (has_ref()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ref());
    }

    // optional .aapt.pb.String str = 2;
    if (has_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->str());
    }

    // optional .aapt.pb.RawString raw_str = 3;
    if (has_raw_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->raw_str());
    }

    // optional .aapt.pb.FileReference file = 4;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->file());
    }

    // optional .aapt.pb.Id id = 5;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional .aapt.pb.Primitive prim = 6;
    if (has_prim()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->prim());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Item::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Item*>(&from));
}

void Item::MergeFrom(const Item& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ref()) {
      mutable_ref()->::aapt::pb::Reference::MergeFrom(from.ref());
    }
    if (from.has_str()) {
      mutable_str()->::aapt::pb::String::MergeFrom(from.str());
    }
    if (from.has_raw_str()) {
      mutable_raw_str()->::aapt::pb::RawString::MergeFrom(from.raw_str());
    }
    if (from.has_file()) {
      mutable_file()->::aapt::pb::FileReference::MergeFrom(from.file());
    }
    if (from.has_id()) {
      mutable_id()->::aapt::pb::Id::MergeFrom(from.id());
    }
    if (from.has_prim()) {
      mutable_prim()->::aapt::pb::Primitive::MergeFrom(from.prim());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Item::CopyFrom(const Item& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item::IsInitialized() const {

  return true;
}

void Item::Swap(Item* other) {
  if (other != this) {
    std::swap(ref_, other->ref_);
    std::swap(str_, other->str_);
    std::swap(raw_str_, other->raw_str_);
    std::swap(file_, other->file_);
    std::swap(id_, other->id_);
    std::swap(prim_, other->prim_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Item::GetTypeName() const {
  return "aapt.pb.Item";
}


// ===================================================================

#ifndef _MSC_VER
const int CompoundValue::kAttrFieldNumber;
const int CompoundValue::kStyleFieldNumber;
const int CompoundValue::kStyleableFieldNumber;
const int CompoundValue::kArrayFieldNumber;
const int CompoundValue::kPluralFieldNumber;
#endif  // !_MSC_VER

CompoundValue::CompoundValue()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.CompoundValue)
}

void CompoundValue::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attr_ = const_cast< ::aapt::pb::Attribute*>(
      ::aapt::pb::Attribute::internal_default_instance());
#else
  attr_ = const_cast< ::aapt::pb::Attribute*>(&::aapt::pb::Attribute::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  style_ = const_cast< ::aapt::pb::Style*>(
      ::aapt::pb::Style::internal_default_instance());
#else
  style_ = const_cast< ::aapt::pb::Style*>(&::aapt::pb::Style::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  styleable_ = const_cast< ::aapt::pb::Styleable*>(
      ::aapt::pb::Styleable::internal_default_instance());
#else
  styleable_ = const_cast< ::aapt::pb::Styleable*>(&::aapt::pb::Styleable::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  array_ = const_cast< ::aapt::pb::Array*>(
      ::aapt::pb::Array::internal_default_instance());
#else
  array_ = const_cast< ::aapt::pb::Array*>(&::aapt::pb::Array::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  plural_ = const_cast< ::aapt::pb::Plural*>(
      ::aapt::pb::Plural::internal_default_instance());
#else
  plural_ = const_cast< ::aapt::pb::Plural*>(&::aapt::pb::Plural::default_instance());
#endif
}

CompoundValue::CompoundValue(const CompoundValue& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.CompoundValue)
}

void CompoundValue::SharedCtor() {
  _cached_size_ = 0;
  attr_ = NULL;
  style_ = NULL;
  styleable_ = NULL;
  array_ = NULL;
  plural_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CompoundValue::~CompoundValue() {
  // @@protoc_insertion_point(destructor:aapt.pb.CompoundValue)
  SharedDtor();
}

void CompoundValue::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete attr_;
    delete style_;
    delete styleable_;
    delete array_;
    delete plural_;
  }
}

void CompoundValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CompoundValue& CompoundValue::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

CompoundValue* CompoundValue::default_instance_ = NULL;

CompoundValue* CompoundValue::New() const {
  return new CompoundValue;
}

void CompoundValue::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_attr()) {
      if (attr_ != NULL) attr_->::aapt::pb::Attribute::Clear();
    }
    if (has_style()) {
      if (style_ != NULL) style_->::aapt::pb::Style::Clear();
    }
    if (has_styleable()) {
      if (styleable_ != NULL) styleable_->::aapt::pb::Styleable::Clear();
    }
    if (has_array()) {
      if (array_ != NULL) array_->::aapt::pb::Array::Clear();
    }
    if (has_plural()) {
      if (plural_ != NULL) plural_->::aapt::pb::Plural::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CompoundValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.CompoundValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Attribute attr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_style;
        break;
      }

      // optional .aapt.pb.Style style = 2;
      case 2: {
        if (tag == 18) {
         parse_style:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_style()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_styleable;
        break;
      }

      // optional .aapt.pb.Styleable styleable = 3;
      case 3: {
        if (tag == 26) {
         parse_styleable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_styleable()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_array;
        break;
      }

      // optional .aapt.pb.Array array = 4;
      case 4: {
        if (tag == 34) {
         parse_array:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_array()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_plural;
        break;
      }

      // optional .aapt.pb.Plural plural = 5;
      case 5: {
        if (tag == 42) {
         parse_plural:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_plural()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.CompoundValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.CompoundValue)
  return false;
#undef DO_
}

void CompoundValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.CompoundValue)
  // optional .aapt.pb.Attribute attr = 1;
  if (has_attr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->attr(), output);
  }

  // optional .aapt.pb.Style style = 2;
  if (has_style()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->style(), output);
  }

  // optional .aapt.pb.Styleable styleable = 3;
  if (has_styleable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->styleable(), output);
  }

  // optional .aapt.pb.Array array = 4;
  if (has_array()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->array(), output);
  }

  // optional .aapt.pb.Plural plural = 5;
  if (has_plural()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->plural(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.CompoundValue)
}

int CompoundValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Attribute attr = 1;
    if (has_attr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attr());
    }

    // optional .aapt.pb.Style style = 2;
    if (has_style()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->style());
    }

    // optional .aapt.pb.Styleable styleable = 3;
    if (has_styleable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->styleable());
    }

    // optional .aapt.pb.Array array = 4;
    if (has_array()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->array());
    }

    // optional .aapt.pb.Plural plural = 5;
    if (has_plural()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->plural());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CompoundValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CompoundValue*>(&from));
}

void CompoundValue::MergeFrom(const CompoundValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_attr()) {
      mutable_attr()->::aapt::pb::Attribute::MergeFrom(from.attr());
    }
    if (from.has_style()) {
      mutable_style()->::aapt::pb::Style::MergeFrom(from.style());
    }
    if (from.has_styleable()) {
      mutable_styleable()->::aapt::pb::Styleable::MergeFrom(from.styleable());
    }
    if (from.has_array()) {
      mutable_array()->::aapt::pb::Array::MergeFrom(from.array());
    }
    if (from.has_plural()) {
      mutable_plural()->::aapt::pb::Plural::MergeFrom(from.plural());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CompoundValue::CopyFrom(const CompoundValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompoundValue::IsInitialized() const {

  return true;
}

void CompoundValue::Swap(CompoundValue* other) {
  if (other != this) {
    std::swap(attr_, other->attr_);
    std::swap(style_, other->style_);
    std::swap(styleable_, other->styleable_);
    std::swap(array_, other->array_);
    std::swap(plural_, other->plural_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CompoundValue::GetTypeName() const {
  return "aapt.pb.CompoundValue";
}


// ===================================================================

#ifndef _MSC_VER
const int Value::kSourceFieldNumber;
const int Value::kCommentFieldNumber;
const int Value::kWeakFieldNumber;
const int Value::kItemFieldNumber;
const int Value::kCompoundValueFieldNumber;
#endif  // !_MSC_VER

Value::Value()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Value)
}

void Value::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  compound_value_ = const_cast< ::aapt::pb::CompoundValue*>(
      ::aapt::pb::CompoundValue::internal_default_instance());
#else
  compound_value_ = const_cast< ::aapt::pb::CompoundValue*>(&::aapt::pb::CompoundValue::default_instance());
#endif
}

Value::Value(const Value& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Value)
}

void Value::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weak_ = false;
  item_ = NULL;
  compound_value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value::~Value() {
  // @@protoc_insertion_point(destructor:aapt.pb.Value)
  SharedDtor();
}

void Value::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete item_;
    delete compound_value_;
  }
}

void Value::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Value& Value::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Format_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Format_2eproto();
#endif
  return *default_instance_;
}

Value* Value::default_instance_ = NULL;

Value* Value::New() const {
  return new Value;
}

void Value::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        comment_->clear();
      }
    }
    weak_ = false;
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
    if (has_compound_value()) {
      if (compound_value_ != NULL) compound_value_->::aapt::pb::CompoundValue::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Value::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:aapt.pb.Value)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_weak;
        break;
      }

      // optional bool weak = 3;
      case 3: {
        if (tag == 24) {
         parse_weak:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &weak_)));
          set_has_weak();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 4;
      case 4: {
        if (tag == 34) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_compound_value;
        break;
      }

      // optional .aapt.pb.CompoundValue compound_value = 5;
      case 5: {
        if (tag == 42) {
         parse_compound_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compound_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Value)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Value)
  return false;
#undef DO_
}

void Value::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Value)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional bool weak = 3;
  if (has_weak()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->weak(), output);
  }

  // optional .aapt.pb.Item item = 4;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->item(), output);
  }

  // optional .aapt.pb.CompoundValue compound_value = 5;
  if (has_compound_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->compound_value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:aapt.pb.Value)
}

int Value::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional bool weak = 3;
    if (has_weak()) {
      total_size += 1 + 1;
    }

    // optional .aapt.pb.Item item = 4;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

    // optional .aapt.pb.CompoundValue compound_value = 5;
    if (has_compound_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->compound_value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Value*>(&from));
}

void Value::MergeFrom(const Value& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_weak()) {
      set_weak(from.weak());
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
    if (from.has_compound_value()) {
      mutable_compound_value()->::aapt::pb::CompoundValue::MergeFrom(from.compound_value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Value::CopyFrom(const Value& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value::IsInitialized() const {

  return true;
}

void Value::Swap(Value* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(comment_, other->comment_);
    std::swap(weak_, other->weak_);
    std::swap(item_, other->item_);
    std::swap(compound_value_, other->compound_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Value::GetTypeName() const {
  return "aapt.pb.Value";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace aapt

// @@protoc_insertion_point(global_scope)
